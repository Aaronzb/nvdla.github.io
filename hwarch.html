
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Hardware Architectural Specification &#8212; NVDLA Documentation</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <link rel="stylesheet" href="_static/nvdla.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/styles.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Data Formats" href="hw/format.html" />
    <link rel="prev" title="Virtual Platform" href="vp.html" /> 
  </head>
  <body>
<header class="navbar">
  <nav class="container navbar navbar-light bg-faded">
    <a class="navbar-brand" href="https://www.nvidia.com/">
      <div class="logo"></div>
    </a>
  </nav>
</header>

    <div class="related" role="navigation" aria-label="related navigation">
      <div class="container">
      <div class="row">
      <h3>Navigation</h3>
      <ul>
        <li class="right first">
          <a href="hw/format.html" title="Data Formats"
             accesskey="N">next</a></li>
        <li class="right">
          <a href="vp.html" title="Virtual Platform"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">NVDLA Open Source Project</a>&#187;</li>
        <li class="nav-item nav-item-1"><a href="contents.html">Documentation</a>&#187;</li> 
      </ul>
      </div>
      </div>
    </div>
  <div class="document">
    <div class="container">
      <div class="row">
        <div class="col-xs-12 col-md-9">
          
  <div class="section" id="hardware-architectural-specification">
<h1>Hardware Architectural Specification<a class="headerlink" href="#hardware-architectural-specification" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The NVIDIA® Deep Learning Accelerator (NVDLA) is a configurable fixed function hardware accelerator targeting inference operations in deep learning applications. It provides full hardware acceleration for a convolutional neural network (CNN) by exposing individual building blocks that accelerate operations associated with each CNN layer (e.g., convolution, deconvolution, fully-connected, activation, pooling, local response normalization, etc.). Maintaining separate and independently configurable blocks means that the NVDLA can be sized appropriatley for many smaller applications where inferencing was previously not feasible due to cost, area, or power constraints. This modular architecture enables a highly configurable solution that readily scales to meet specific inferencing needs.</p>
<p><strong>About This Document</strong></p>
<p>This document focuses on the logical organization and control of the NVIDIA Deep Learning Accelerator. It provides information for those blocks and interfaces that control fundamental operations. The blocks detailed in this document include a functional overview, configuration options, and register listings for that block.  All features and functions of all blocks may not be present in every NVDLA implementation.</p>
</div>
<div class="section" id="functional-description">
<h2>Functional Description<a class="headerlink" href="#functional-description" title="Permalink to this headline">¶</a></h2>
<p>NVDLA operation begins with the management processor (either a microcontroller or the main CPU) sending down the configuration of one hardware layer, along with an “activate” command. If data dependencies do not preclude this, multiple hardware layers can be sent down to different blocks and activated at the same time (i.e., if there exists another layer whose inputs do not depend on the output from the previous layer). Because every block has a double-buffer for its configuration registers, it can also capture a second layer’s configuration to begin immediately processing when the active layer has completed. Once a hardware engine finishes its active task, it will issue an interrupt to the management processor to report the completion, and the management processor will then begin the process again. This command-execute-interrupt flow repeats until inference on the entire network is complete.</p>
<p>NVDLA has two modes of operation: independent mode and fused mode. Independent operation refers to each individual block being configured for when and what it executes, with each block working on its assigned task. Independent operation begins and ends with the assigned block performing memory-to-memory operations, in and out of main system memory or dedicated SRAM memory. Fused operation is similar to independent operation, however, some blocks can be assembled as a pipeline; this improves performance by bypassing the round trip through memory, instead having blocks communicate with each other through small FIFOs (i.e., the convolution core can pass data to the Single Data Point Processor, which can pass data to the Planar Data Processor, and in turn to the Cross-channel Data Processor without performing memory-to-memory operations in between).</p>
<div class="figure align-center" id="id6">
<span id="fig-arch-nvdla-block-diagram"></span><img alt="&quot;Headless NVDLA core&quot; architectural drawing.  A configuration interface block is connected to the outside world through the CSB/interrupt interface.  The memory interface block is connected outside with a DBB interface and a second, optional, DBB interface.  The memory interface connects to a convolution buffer, which connects to a convolution core; the memory interface also connects to the activation engine, the pooling engine, local response normalization engine, reshape engine, and bridge DMA engine.   The convolution core, activation engine, pooling engine, and local response normalization engine also form a pipeline." src="_images/nvdla-primer-core-diagram.svg" /><p class="caption"><span class="caption-number">Fig. 7 </span><span class="caption-text">NVDLA Core Block Diagram.</span></p>
</div>
<p>Each block in the NVDLA architecture exists to support specific operations integral to inference on deep neural networks. Inference operations are divided into five groups:</p>
<ul class="simple">
<li>Convolution operations (Convolution core and buffer blocks)</li>
<li>Single Data Point operations (Activation engine block)</li>
<li>Planar Data operations (Pooling engine block)</li>
<li>Multi-Plane operations (Local resp. norm block)</li>
<li>Data Memory and Reshape operations (Reshape and Bridge DMA blocks)</li>
</ul>
<p>Different deep learning applications require different inference operations. For example, the workload of real image segmentation is very different from that of face-detection. As a result, performance, area, and power requirements for any given NVDLA design will vary. The NVDLA architecture implements a series of hardware parameters that are used to define feature selection and design sizing. These hardware parameters provide the basis for creating an NVDLA hardware design specification. The design specification identifies the supported features and performance characteristics for an NVDLA implementation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The descriptions in the following sections contain references to or identify various hardware paramters and settings that might influence performance. Refer to the Hardware Paramters sections of this document for more information.</p>
</div>
<div class="section" id="convolution-operations">
<h3>Convolution Operations<a class="headerlink" href="#convolution-operations" title="Permalink to this headline">¶</a></h3>
<p>Convolution operations work on two sets of data: one set of offline-trained “weights” (which remain constant between each run of inference), and one set of input “feature” data (which varies with the network’s input). The NVDLA Convolution Engine exposes parameters that enable several different modes of operation. Each of these modes include optimizations that improve performance over a naive convolution implementation:</p>
<ul class="simple">
<li>Direct</li>
<li>Image-input</li>
<li>Winograd</li>
<li>Batching</li>
</ul>
<p>Enabling different modes of operation allows for the ability to map many different sizes of convolutions onto the hardware with higher efficiency. Support for sparse weight compression saves memory bandwidth. Built-in Winograd convolution support improves compute efficiency for certain sizes of filters. Batching convolution, can save additional memory bandwidth by reusing weights when running multiple inferences in parallel. To avoid repeated accesses to system memory, the NVDLA convolution engine has an internal RAM reserved for weight and input feature storage, referred to as the “convolution buffer”.  This design greatly improves memory efficiency over sending a request to the system memory controller for each independent time a weight or feature is needed.</p>
<div class="section" id="direct-convolution-mode">
<span id="direct-convolution"></span><h4>Direct Convolution Mode<a class="headerlink" href="#direct-convolution-mode" title="Permalink to this headline">¶</a></h4>
<p>Direct convolution mode is the basic mode of operation. NVDLA incorporates a wide multiply–accumulate (MAC) pipeline to support efficient parallel direct convolutional operation. There are two key factors that impact convolution function performance: Memory bandwidth and MAC efficiency.</p>
<p>NVDLA supports two memory bandwidth optimization features that can significantly help to reduce memory bandwidth requirements for CNN layer(s) that require huge data exchange, e.g. fully-connected layers.</p>
<ul class="simple">
<li><strong>Sparse compression.</strong> The sparser the feature data and/or weight data, the less traffic on memory bus.  A 60% sparse network (60% of the data are zero) can almost cut the memory bandwidth requirement to half.</li>
<li><strong>Second memory interface.</strong> Provides efficient on-chip buffering, which can increase memory traffic bandwidth and also reduce the memory traffic latency.  Usually an on-chip SRAM can provide 2x~4x of DRAM bandwidth with 1/10 ~ 1/4 latency.</li>
</ul>
<p>The second key factor that impacts convolution function performance is MAC efficiency.  The number of MAC instances is determined by <em>(Atomic-C * Atomic-K)</em>.  However, if a layer’s input feature data channel number is not aligned with the Atomic-C setting or the output feature data kernel number is not aligned with the Atomic-K setting, there will be times that not all MACs are valid which will result in a drop in MAC utilization. For example, if the NVDLA design specification has Atomic-C = 16 and Atomic-K = 64 (which would result in 1024 MAC instances), and one layer of the network has the input feature data channel number = 8 and output feature data kernel number = 16, then the MAC utilization will be only 1/8th (i.e., only 128 MACs will be utilized with the others being idle at all times).</p>
<p>Hardware Parameters:</p>
<ul class="simple">
<li>Atomic – C sizing</li>
<li>Atomic – K sizing</li>
<li>Data type supporting</li>
<li>Feature supporting – Compression</li>
<li>Feature supporting – Second Memory Bus</li>
</ul>
</div>
<div class="section" id="image-input-convolution-mode">
<h4>Image-Input Convolution Mode<a class="headerlink" href="#image-input-convolution-mode" title="Permalink to this headline">¶</a></h4>
<p>Image-input mode is a special direct convolution mode for the first layer, which contains the input feature data from an image surface. Considering that the image surface format is quite different from the normal feature data format, feature data fetching operations follow a different path from direct convolution operations.  Normally the first layer only has 3 channels for image input, additional logic was added here to enhance MAC utilization. Even though the first layer has 3 (or even 1) channel, a channel extension feature maintains average MAC utilization close to 50%, even if Atomic-C
setting is large (e.g., 16).</p>
<p>Hardware Parameters:</p>
<ul class="simple">
<li>All from Direct Convolution mode +</li>
<li>Image input support</li>
</ul>
</div>
<div class="section" id="winograd-convolution-mode">
<span id="winograd"></span><h4>Winograd Convolution Mode<a class="headerlink" href="#winograd-convolution-mode" title="Permalink to this headline">¶</a></h4>
<p>Winograd convolution refers to an optional algorithm used to optimize the performance of direct convolution. The Winograd convolution reduces the number of
multiplications, while increasing the adders to deal with the additional
transformation. As the number of additions for both pre-calculation and
post-calculation is much less than the number of operations in the MAC
array, the overall number of operations is reduced.  A large number of MAC
operations are avoided for the same convolutional function. For example, a 3x3 filter-sized convolution with winograd, reduces the
number of MAC operations by a factor of 2.25x, improving both performance
and power efficiency. Weight conversion is done offline, so the total weight data size is
expected to increase.  Winograd feature is very useful for the maths-limited
layers; 3x3 or larger filter-sized layers are always maths-limited, so
match well to the winograd feature.</p>
<p>The equation of Winograd convolution used
in convolution core is:</p>
<div class="math">
\[S = A^T \left[ \left( Gg G^T \right) \odot \left( C^T dC \right) \right] A\]</div>
<p>Here symbol <span class="math">\(\odot\)</span> indicates element-wise multiplication. That means
the winograd function requires a pre-calculation of fixed matrix operation
before normal direct convolutional MAC array and a post-calculation of
another fixed matrix operation after normal direct convolutional MAC array.</p>
<p>Hardware Parameters:</p>
<ul class="simple">
<li>Feature supporting – Winograd</li>
</ul>
</div>
<div class="section" id="batching-convolution-mode">
<span id="batching"></span><h4>Batching Convolution Mode<a class="headerlink" href="#batching-convolution-mode" title="Permalink to this headline">¶</a></h4>
<p>The NVDLA batching feature supports processing of multiple sets of input activations (from multiple images) at a time.  This re-uses weights and saves significant memory bandwidth, improving performance and power. The memory bandwidth requirement for fully-connected layers is much larger than the calculation resource. The size of weight data in fully-connected layers is significant and is only used a single time in MAC functions (this is one of the leading causes of bottlenecks in memory bandwidth). Allowing multiple sets of activations to share the same weight data means they can run at the same
time (reducing overall run-time). The run-time for a single batch is close to that for a single-layer; overall performance is close to [batching_size] X [single-layer performance].</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Support for large batching sizes means a large area cost for activation buffering. Maximum batching size is limited by the convolution buffer size, so the maximum batching number is a hardware limitation in the design specification.</p>
</div>
<p>Hardware Parameters:</p>
<ul class="simple">
<li>Feature batch support</li>
<li>Max batch number</li>
</ul>
</div>
<div class="section" id="convolution-buffer">
<h4>Convolution Buffer<a class="headerlink" href="#convolution-buffer" title="Permalink to this headline">¶</a></h4>
<p>The Convolution buffer is one pipeline stage of the Convolution core. It
contains both the weight data and the feature data for the convolution
function. The ratio of weight data size to feature data size varies
within different networks and even within a single network (different
layers can have completely different ratios between feature and weight data). To accomodate these differences the convolution buffer
enables a configurable storage strategy for both weight data and
feature data.</p>
<p>The Convolution buffer requires at least 4 ports for data access:</p>
<ul class="simple">
<li>Read port for feature data</li>
<li>Read port for weight data</li>
<li>Write port for feature data</li>
<li>Write port for weight data</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If compression features are supported, ports for compression tags are required. There are different ways these ports can be shared; refer to the reference design and documentation for more information – banking with dedicated configuration.</p>
</div>
<p>The Convolution buffer size depends on various factors; the primary factor is CNN size (i.e. feature data size and weight data
size). It is preferable if the full size of either weight data or feature data of one hardware layer can be stored in the Convolution buffer (removes need to fetch data multiple times). Convolution read bandwidth determines the width of the read port.  In order to feed the required amount of Atomic-C data in a single cycle,(data_size*Atomic-C) of data width is required.  For example, for an atomic-C of 16 on an INT8 convolution function, a 128-bit width (16 bytes)
is required.</p>
<p>Hardware Parameters:</p>
<ul class="simple">
<li>BUFF bank #</li>
<li>BUFF bank size</li>
</ul>
</div>
</div>
<div class="section" id="single-data-point-operations">
<h3>Single Data Point Operations<a class="headerlink" href="#single-data-point-operations" title="Permalink to this headline">¶</a></h3>
<p>The Single Data Point Processor (SDP) allows for the application of both linear and non-linear functions onto individual data points.  This is commonly used immediately after convolution in CNN systems.  The SDP provides native support for linear functions (e.g., simple bias and scaling) and uses lookup tables (LUTs) to implement non-linear functions. This combination supports most common activation functions as well as other element-wise operations including: ReLU, PReLU, precision scaling, batch normalization, bias addition, or other complex non-linear functions, such as a sigmoid or a hyperbolic tangent.</p>
<p>Hardware Parameters:</p>
<ul class="simple">
<li>SDP function support</li>
<li>SDP throughput</li>
</ul>
<div class="section" id="linear-functions">
<h4>Linear Functions<a class="headerlink" href="#linear-functions" title="Permalink to this headline">¶</a></h4>
<p>NVDLA supports multiple instances of linear functions (which are mostly scaling functions). There are several methods that can be used for of setting the scaling factor and bias: 1) CNN setting - the scaling factor and bias are the same throughout the whole CNN, this scaling factor are comes from a register configuration; 2) Channel setting - the scaling factor and bias are the same within a single planar (i.e., the same channel value), these scaling factors  come from the memory interface; 3) Per pixel setting - the scaling factor and bias are different for every single feature, the factors and bias will come from the memory interface.</p>
<ul class="simple">
<li><strong>Precision Scaling.</strong>  Control memory bandwidth throughout the full inference process; feature data can be scaled to its full range before chunking into lower precision and writing to memory . Scale key resources (e.g., MAC array) to support full range for best inference result (other linear functions may be applied). Revert input data before any of the non-linear functions (i.e., keep input data of non-linear functions as original data).</li>
<li><strong>Batch Normalization.</strong> In an inference function batch normalization requires a linear function with a trained scaling factor. SDP can support a per-layer parameter or a per-channel parameter to do the batch normalization operation.</li>
<li><strong>Bias Addition.</strong> Some layers require the bias function at the output side, which means that they need to provide an offset (either from a per-layer setting or per-channel memory surface or per-feature memory surface) to the final result.</li>
<li><strong>Element-Wise Operation.</strong> The element-wise layer (used in some CNN) refers to a type of operation between two feature data cubes which have the same W, H and C size. These two W x H x C feature data cubes do element-wise addition, multiplication or max/min comparison operation and output one W x H x C feature data cube. NVDLA supports common operations in element-wise operations (e.g., add, sub, multiply, max).</li>
</ul>
</div>
<div class="section" id="non-linear-functions">
<h4>Non-Linear Functions<a class="headerlink" href="#non-linear-functions" title="Permalink to this headline">¶</a></h4>
<p>There are several non-linear functions that are required to support Deep Learning algorithms. Some of these are supported using dedicated hardware logic while more complex functions incorporate the use of a dedicated Look-Up-Table.</p>
<ul>
<li><p class="first">ReLU, for an input <span class="math">\(x\)</span>, the output is <span class="math">\(\textrm{max}(x, 0)\)</span>.</p>
</li>
<li><p class="first">PReLU, different from ReLU, PReLU still keep a value small linear factor instead of cutting to zero:</p>
<p><span class="math">\(y = \begin{cases} x &amp; x &gt; 0 \\ k * x &amp; x &lt; 0 \end{cases}\)</span></p>
</li>
<li><p class="first">Sigmoid, for an input <span class="math">\(x\)</span>, the output is <span class="math">\(\frac{1}{1+e^{-x}}\)</span></p>
</li>
<li><p class="first">Hyperbolic tangent, for an input <span class="math">\(x\)</span>, the output is
<span class="math">\(\frac{1-e^{-2x}}{1+e^{-2x}}\)</span></p>
</li>
<li><p class="first">And more…</p>
</li>
</ul>
</div>
</div>
<div class="section" id="planar-data-operations">
<h3>Planar Data Operations<a class="headerlink" href="#planar-data-operations" title="Permalink to this headline">¶</a></h3>
<p>The Planar Data Processor (PDP) supports specific spatial operations that are common in CNN applications.  It is configurable at runtime to support different pool group sizes, and supports three pooling functions:</p>
<ul class="simple">
<li>maximum-pooling – get maximum value from pooling window.</li>
<li>minimum-pooling – get minimum value from pooling window.</li>
<li>average-pooling – average the feature value in the pooling window.</li>
</ul>
<p>The PDP unit has a dedicated memory interface to fetch input data from memory and outputs directly to memory.</p>
<p>Hardware Parameters:</p>
<ul class="simple">
<li>PDP throughput</li>
</ul>
</div>
<div class="section" id="multi-plane-operations">
<h3>Multi-Plane Operations<a class="headerlink" href="#multi-plane-operations" title="Permalink to this headline">¶</a></h3>
<p>The Cross-channel Data Processor (CDP) is a specialized unit built to apply the local response normalization (LRN) function - a special normalization function that operates on channel dimensions, as opposed to the spatial dimensions.</p>
<div class="math">
\[Result_{w,h,c} =
  \frac
    {Source_{w,h,c}}
    {\left( j +
\frac{\alpha}{n}\sum\limits_{i=\textrm{max}\left(0,c-\frac{n}{2}\right)}^{\textrm{min}\left(C-1,c+\frac{n}{2}\right)}{Source_{w,h,i}}^2\right)^{\beta}}\]</div>
<p>Hardware Parameters:</p>
<ul class="simple">
<li>CDP throughput</li>
</ul>
</div>
<div class="section" id="data-memory-and-reshape-operations">
<h3>Data Memory and Reshape Operations<a class="headerlink" href="#data-memory-and-reshape-operations" title="Permalink to this headline">¶</a></h3>
<div class="section" id="bridge-dma">
<h4>Bridge DMA<a class="headerlink" href="#bridge-dma" title="Permalink to this headline">¶</a></h4>
<p>The bridge DMA (BDMA) module provides a data copy engine to move data between the system DRAM and a dedicated high-performance memory interface, where present. Provides an accelerated path to move data between these two non-connected memory systems.</p>
<p>Hardware Parameters:</p>
<ul class="simple">
<li>BDMA function support</li>
</ul>
</div>
<div class="section" id="data-reshape-engine">
<span id="rubik"></span><h4>Data Reshape Engine<a class="headerlink" href="#data-reshape-engine" title="Permalink to this headline">¶</a></h4>
<p>The data reshape engine performs data format transformations (e.g., splitting or slicing, merging, contraction, reshape-transpose). Data in memory often needs to be reconfigured or reshaped in the process of performing inferencing on a convolutional network.  For example: “slice” operations may be used to separate out different features or spatial regions of an image; “reshape-transpose” operations (common in deconvolutional networks) create output data with larger dimensions than the input dataset.</p>
<p>The Rubik function transforms data mapping format without any data calculations. It supports three working modes:</p>
<ul class="simple">
<li><strong>Contract Mode.</strong> Contract mode in Rubik transforms mapping format are used to de-extend the cube. It’s a second hardware layer to support deconvolution. Normally, a software deconvolution layer has deconvolution x stride and y stride that are greater than 1; with these strides the output of phase I hardware-layer is a channel-extended data cube.</li>
<li><strong>Split Mode and Merge Mode.</strong> Split and merge are two opposite operation modes in Rubik. Split transforms a data cube into M-planar formats (NCHW). The number of planes is equal to channel size. Merge transforms a serial of planes to a feature data cube.</li>
</ul>
<p>Hardware Parameters:</p>
<ul class="simple">
<li>Rubik function support</li>
</ul>
</div>
</div>
</div>
<div class="section" id="hardware-parameters">
<span id="scalability"></span><h2>Hardware Parameters<a class="headerlink" href="#hardware-parameters" title="Permalink to this headline">¶</a></h2>
<p>Different deep learning applications require different inference operations. For example, the workload of real image segmentation is very different from
that of face-detection.  As a result, performance, area, and power requirements for any given NVDLA design will vary. NVDLA addresses this with a set of configurable hardware parameters that are used to create an implementation that fits the application needs.</p>
<p>Hardware parameters provide the basis for creating an NVDLA hardware design specification. The design specification identifies the supported features and performance characteristics for an NVDLA implementation. There are two categories of hardware parameters: Feature Selection and Design Sizing. A given NVDLA implementation is defined by the parameters and settings selected.</p>
<div class="section" id="feature-selection">
<h3>Feature Selection<a class="headerlink" href="#feature-selection" title="Permalink to this headline">¶</a></h3>
<p>Feature parameters identify which individual features an NVDLA implementation will support. Configurable options include:</p>
<div class="section" id="data-type">
<h4>Data Type<a class="headerlink" href="#data-type" title="Permalink to this headline">¶</a></h4>
<p>NVDLA can support one data type for specific network, or support multiple data types for more general purpose. NVDLA hardware architecture can make proper sharing between the different data types for both area cost and power efficiency consideration.</p>
<ul class="simple">
<li>Parameter:  Data type supporting</li>
<li>Values:  Binary/INT4/INT8/INT16/INT32/FP16/FP32/FP64</li>
<li>Affected operations: All</li>
</ul>
</div>
<div class="section" id="id1">
<h4>Winograd<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>Winograd is an optimization feature for the convolutional function. It can improve performance by increasing MAC efficiency, and it can also help with the overall power efficiency.  See <a class="reference internal" href="#winograd"><span class="std std-ref">Winograd Convolution Mode</span></a> for more information.</p>
<ul class="simple">
<li>Parameter:  Feature supporting – Winograd</li>
<li>Possible values: Yes/No</li>
<li>Affected operations: Convolution</li>
</ul>
</div>
<div class="section" id="id2">
<h4>Batching<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Batching is an optimization feature for convolution. It improves
performance by both increasing MAC efficiency and saving memory traffic.
See <a class="reference internal" href="#batching"><span class="std std-ref">Batching Convolution Mode</span></a> for more information.</p>
<ul class="simple">
<li>Parameter:  Feature supporting – batch</li>
<li>Possible values: Yes/No</li>
<li>Affected operations: Convolution</li>
</ul>
</div>
<div class="section" id="sparse-compression">
<h4>Sparse Compression<a class="headerlink" href="#sparse-compression" title="Permalink to this headline">¶</a></h4>
<p>Sparse compression is an optimization feature for convolution. It can
reduce the total amount of memory traffic and thus improve performance and
save power. See <a class="reference internal" href="#direct-convolution"><span class="std std-ref">Direct Convolution Mode</span></a> for more information.</p>
<ul class="simple">
<li>Parameter:  Feature supporting – Sparse Compression</li>
<li>Possible values: Weight/Feature/Neither/Both</li>
<li>Affected operations: Convolution</li>
</ul>
</div>
<div class="section" id="second-memory-bus">
<h4>Second Memory Bus<a class="headerlink" href="#second-memory-bus" title="Permalink to this headline">¶</a></h4>
<p>NVDLA always has a basic interface to external memory over its DBBIF.
Besides that, NVDLA can also support a second memory bus interface names
SRAMIF. This interface can connect to on-chip SRAM or other
high-bandwidth low-latency buses to improve the overall performance.</p>
<ul class="simple">
<li>Parameter:  Feature supporting – Second Memory Bus</li>
<li>Possible values: Yes/No</li>
<li>Affected operations: All</li>
</ul>
</div>
<div class="section" id="image-input">
<h4>Image Input<a class="headerlink" href="#image-input" title="Permalink to this headline">¶</a></h4>
<p>Planar image data is an important input resource to Deep Learning, and there
are a large number of image surface formats.  So, the supported formats for
NVDLA input can be very important for the first hardware layer of NVDLA.</p>
<ul class="simple">
<li>Parameter:  Image input support</li>
<li>Possible values: combinations of 8-bit/16-bit/both; RGB/YUV/both; non-planar/semi-planar/full-planar</li>
<li>Affected operations: Convolution</li>
</ul>
</div>
<div class="section" id="single-data-point-support">
<h4>Single Data Point Support<a class="headerlink" href="#single-data-point-support" title="Permalink to this headline">¶</a></h4>
<p>There are many nonlinear curves used as activation functions for Deep
Learning, including (P)ReLU, tanh, sigmoid, and more.  Some of these, such
as ReLU, are very simple and can be implemented trivially with scaling
beyond a threshold; others require extra memory to approximate using a
lookup table.</p>
<ul class="simple">
<li>Parameter:  SDP function support</li>
<li>Possible values:  Scaling/LUT</li>
<li>Affected operations: Single Data Point</li>
</ul>
</div>
<div class="section" id="bridge-dma-support">
<h4>Bridge DMA Support<a class="headerlink" href="#bridge-dma-support" title="Permalink to this headline">¶</a></h4>
<p>In case that NVDLA supports second memory interface, the Bridge DMA (BDMA) unit can
do data copy between the main memory interface an second memory
interface.</p>
<ul class="simple">
<li>Parameter:  BDMA function support</li>
<li>Possible values: Yes/No</li>
<li>Affected operations:  MISC</li>
</ul>
</div>
<div class="section" id="data-reshape-engine-support">
<h4>Data Reshape Engine Support<a class="headerlink" href="#data-reshape-engine-support" title="Permalink to this headline">¶</a></h4>
<p>The Rubik function transforms data mapping format without any data calculations. See
<a class="reference internal" href="#rubik"><span class="std std-ref">Data Reshape Engine</span></a> for more information.</p>
<ul class="simple">
<li>Parameter:  Rubik function support</li>
<li>Possible values: Yes/No</li>
<li>Affected operations:  MISC</li>
</ul>
</div>
</div>
<div class="section" id="design-sizing">
<h3>Design Sizing<a class="headerlink" href="#design-sizing" title="Permalink to this headline">¶</a></h3>
<p>Design sizing parameters indicate the parallelism that is supported in the
NVDLA Hardware.  A larger value usually means higher performance but with an
associated higher area and/or power cost.</p>
<div class="section" id="atomicc">
<h4>Atomic–C<a class="headerlink" href="#atomicc" title="Permalink to this headline">¶</a></h4>
<p>This value indicates the parallel MAC operation in input feature channel
dimension. This parameter impacts total MAC number, convolutional buffer
read bandwidth.</p>
<ul class="simple">
<li>Parameter:  Atomic – C sizing</li>
<li>Values: 16~128</li>
<li>Affected operations: Convolution</li>
</ul>
</div>
<div class="section" id="atomick">
<h4>Atomic–K<a class="headerlink" href="#atomick" title="Permalink to this headline">¶</a></h4>
<p>This value indicates the parallel MAC operation at output feature
channel dimension. This parameter impacts total MAC number, accumulator
instance number, convolutional write-back bandwidth.</p>
<p>As the MAC array has 2 dimensions, so the total MAC number is (Atomic-C
* Atomic-K).</p>
<ul class="simple">
<li>Parameter:  Atomic – K sizing</li>
<li>Range of values: 4~16</li>
<li>Affected scope: Convolutional function</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Both Atomic-C and Atomic-K parameters are referring to the lowest precision, the higher precision may be reduced accordingly. For example, if NVDLA supports both INT8 and INT16, then the Atomic-C and Atomic-K parameters are referring to INT8 case, INT16 is expected to have lower parallel.</p>
</div>
</div>
<div class="section" id="single-data-point-throughput">
<h4>Single Data Point Throughput<a class="headerlink" href="#single-data-point-throughput" title="Permalink to this headline">¶</a></h4>
<p>The Single Data Point (SDP) throughput indicates the number of instances of SDP pipelines.
The number of SDP pipelines determines the number of output features
that can be generated each cycle.</p>
<ul class="simple">
<li>Parameter:  SDP throughput</li>
<li>Range of values: 1~16</li>
<li>Affected scope: SDP</li>
</ul>
</div>
<div class="section" id="planar-data-processor-throughput">
<h4>Planar Data Processor Throughput<a class="headerlink" href="#planar-data-processor-throughput" title="Permalink to this headline">¶</a></h4>
<p>The Planar Data Processor (PDP) throughput indicates the number of output features that can be
generated each cycle. A value of 0 indicates that no PDP blocks will be
included and the planar data processor operation will not be supported.</p>
<ul class="simple">
<li>Parameter:  PDP throughput</li>
<li>Range of values: 0~4</li>
<li>Affected operations: PDP</li>
</ul>
</div>
<div class="section" id="cross-channel-data-processor-throughput">
<h4>Cross-Channel Data Processor Throughput<a class="headerlink" href="#cross-channel-data-processor-throughput" title="Permalink to this headline">¶</a></h4>
<p>The CDP throughput indicates the number of output features that can be
generated every cycle. A value of 0 indicates that no CDP block will be
included and multi-plane operations will not be supported by the
resulting implementation</p>
<ul class="simple">
<li>Parameter:  CDP throughput</li>
<li>Range of values: 0~4</li>
<li>Affected operations: CDP</li>
</ul>
</div>
<div class="section" id="convolution-buffer-banks">
<h4>Convolution Buffer Banks<a class="headerlink" href="#convolution-buffer-banks" title="Permalink to this headline">¶</a></h4>
<p>This value indicates the number of convolutional buffer banks. The
number of banks defines the granularity of CBUF storage allocation
between weights and activations. Together with the bank size parameter,
they determine the size of overall convolutional buffer.</p>
<ul class="simple">
<li>Parameter:  BUFF bank #</li>
<li>Range of values: 2~32</li>
<li>Affected operations: Convolution</li>
</ul>
</div>
<div class="section" id="convolution-buffer-bank-size">
<h4>Convolution Buffer Bank Size<a class="headerlink" href="#convolution-buffer-bank-size" title="Permalink to this headline">¶</a></h4>
<p>This value indicates the size of a single convolutional buffer bank.
Together with the bank number parameter, they determine the size of
overall convolutional buffer.</p>
<ul class="simple">
<li>Parameter:  BUFF bank size</li>
<li>Range of values: 4KB~32KB</li>
<li>Affected operations: Convolution</li>
</ul>
</div>
<div class="section" id="convolution-batching">
<h4>Convolution Batching<a class="headerlink" href="#convolution-batching" title="Permalink to this headline">¶</a></h4>
<p>This value indicates the maximum batching number that convolution
function can support. Usually larger value of this parameter has area
impact as more buffering is required at accumulator side.</p>
<ul class="simple">
<li>Parameter:  MAX Batch number</li>
<li>Range of values: 1~32</li>
<li>Affected operations: Convolution</li>
</ul>
</div>
</div>
<div class="section" id="data-types-and-precision">
<h3>Data Types and Precision<a class="headerlink" href="#data-types-and-precision" title="Permalink to this headline">¶</a></h3>
<p>NVDLA supports multiple data type inference based on different workloads. Use of these parameters can be used to improve network accuracy for a given power and performance constraint. Floating point data has a high precision (FP64/FP32/FP16); integer data type (INT16/INT8/INT4), or even single bit binary can be used for lower precision applications.</p>
<div class="section" id="precision-scaling-convertor">
<h4>Precision Scaling Convertor<a class="headerlink" href="#precision-scaling-convertor" title="Permalink to this headline">¶</a></h4>
<p>The precision scaling convertors are normally used before some very critical limited resources, like before writing data to memory or before entering MAC array.</p>
<p>The formula for convertor is: <span class="math">\(y = \textrm{saturation} ((x -
\textrm{offset}) * \textrm{scaling} &gt;&gt; \textrm{shifter})\)</span>.</p>
</div>
<div class="section" id="precision-shifter">
<h4>Precision Shifter<a class="headerlink" href="#precision-shifter" title="Permalink to this headline">¶</a></h4>
<p>A shifter is mostly used at the bits adjustment in the middle of the pipeline.
For example, the accumulator bit width is far more than the input data, so
before data sent out to SDP, we need to chunk it by a shifter.</p>
<p>Shifter is a simplified convertor, formula as: <span class="math">\(y = \textrm{saturate}(x &lt;&lt;
\textrm{shifter})\)</span>.</p>
</div>
<div class="section" id="look-up-table">
<h4>Look Up Table<a class="headerlink" href="#look-up-table" title="Permalink to this headline">¶</a></h4>
<p>LUT are used to deal with non-linear function in a network such as sigmoid and tanh activation functions or for local response normalization.</p>
</div>
</div>
<div class="section" id="small-nvdla-implementation-example">
<h3>Small NVDLA Implementation Example<a class="headerlink" href="#small-nvdla-implementation-example" title="Permalink to this headline">¶</a></h3>
<p>Small sized NVDLA implementations target smaller workloads, as such, these implementations only need to have very basic support.  Because of the light workload, 64 INT8 MACs with Atomic-C=16 and Atomic-K=4 should be good enough. All other optimization features can be removed to save area.  For image input format, supporting a basic format like A8R8G8B8 is likley good enough.  If pooling and normalization functions are required, it is possible to limit throughput.  As to the convolutional buffer, 4 banks each with 8KB size (totally 32KB size) can support.</p>
<p><strong>Example hardware parameter settings:</strong></p>
<ul class="simple">
<li>Data type supporting = INT8</li>
<li>Feature supporting - Winograd = No</li>
<li>Feature supporting - Second Memory Bus = No</li>
<li>Feature supporting - Compression = No</li>
<li>Image input support = A8R8G8B8</li>
<li>SDP function support = Single Scaling</li>
<li>BDMA function support = No</li>
<li>Rubik function support = No</li>
<li>Atomic - C sizing = 8</li>
<li>Atomic - K sizing = 8</li>
<li>SDP throughput = 4</li>
<li>PDP throughput = 2</li>
<li>CDP throughput = 2</li>
<li>BUFF bank # = 4</li>
<li>BUFF bank size = 8KB</li>
</ul>
</div>
<div class="section" id="large-nvdla-implementation-example">
<h3>Large NVDLA Implementation Example<a class="headerlink" href="#large-nvdla-implementation-example" title="Permalink to this headline">¶</a></h3>
<p>Larger NVDLA implementations target heavier workloads. This model serves as a better choice when the primary emphasis is on higher performance and versatility. Increasing the Atomic-C and Atomic-K to 64/16 increases NVDLA performance to a maximum of 2K operations every cycle; enabling all other optimizations increases real operations further.  Other post-processing throughput also needs to increase (e.g., PDP and CDP throughput changed to 4). When targeting a larger CNN, set a larger convolution buffer (e.g., 32KB * 16 = 512KB).</p>
<p><strong>Example hardware parameter settings:</strong></p>
<ul class="simple">
<li>Data type supporting = FP16/INT16</li>
<li>Feature supporting - Winograd = Yes</li>
<li>Feature supporting - Second Memory Bus = Yes</li>
<li>Feature supporting - Compression = Yes</li>
<li>Image input support = A8R8G8B8/YUV16 Semi-planar</li>
<li>SDP function support = Scaling/LUT</li>
<li>BDMA function support = Yes</li>
<li>Rubik function support = No</li>
<li>Atomic - C sizing = 64</li>
<li>Atomic - K sizing = 16</li>
<li>SDP throughput = 16</li>
<li>PDP throughput = 4</li>
<li>CDP throughput = 4</li>
<li>BUFF bank # = 16</li>
<li>BUFF bank size = 32KB</li>
</ul>
</div>
</div>
<div class="section" id="external-interfaces">
<span id="id3"></span><h2>External Interfaces<a class="headerlink" href="#external-interfaces" title="Permalink to this headline">¶</a></h2>
<p>The NVDLA has four interfaces to the system as a whole.  These are:</p>
<ul class="simple">
<li><strong>Configuration space bus (“CSB”).</strong> The host system accesses and
configures the NVDLA register set with a very simple address/data
interface.  Some systems may directly connect the host CPU to the CSB
interface, with a suitable bus bridge; other, potentially larger, systems
will instead connect a small microcontroller to the CSB interface,
offloading some of the work of managing the NVDLA to the external core.</li>
<li><strong>External interrupt (“IRQ”):</strong>  Certain states in the NVDLA demand
asynchronous reporting to the processor that is commanding the NVDLA,
these states include operation completion and error conditions,.  The
external interrupt interface provides a single output pin that complements
the CSB interface.</li>
<li><strong>Data backbone (“DBBIF”):</strong> The NVDLA contains its own DMA engine to load
and store values (including parameters and datasets) from the rest of the
system.  The data backbone is an AMBA AXI4-compliant interface that is
intended to access large quantities of relatively high-latency memory
(such as system DRAM).</li>
<li><strong>SRAM connection (“SRAMIF”):</strong> Some systems may have the need for more
throughput and lower latency than the system DRAM can provide, and may
wish to use a small SRAM as a cache to improve the NVDLA’s performance.  A
secondary AXI4-compliant interface is provided for an optional SRAM to be
attached to the NVDLA.</li>
</ul>
<p>Below, we present two examples of platforms that integrate an NVDLA, and how
they attach these external connections to the rest of the system.</p>
<div class="figure align-center" id="id7">
<span id="fig-small-nvdla"></span><a class="reference internal image-reference" href="_images/nvdla-hwarch-small.svg"><img alt="_images/nvdla-hwarch-small.svg" src="_images/nvdla-hwarch-small.svg" /></a>
<p class="caption"><span class="caption-number">Fig. 8 </span><span class="caption-text">Small NVDLA system.</span></p>
</div>
<div class="figure align-center" id="id8">
<span id="fig-large-nvdla"></span><a class="reference internal image-reference" href="_images/nvdla-hwarch-large.svg"><img alt="_images/nvdla-hwarch-large.svg" src="_images/nvdla-hwarch-large.svg" /></a>
<p class="caption"><span class="caption-number">Fig. 9 </span><span class="caption-text">Large NVDLA system.</span></p>
</div>
<p><a class="reference internal" href="#fig-small-nvdla"><span class="std std-numref">Fig. 8</span></a> shows a small system, for which NVDLA is directly
connected to the main CPU.  The small system has no NVDLA-dedicated SRAM,
and all accesses hit the main system memory.  By comparison,
<a class="reference internal" href="#fig-large-nvdla"><span class="std std-numref">Fig. 9</span></a> shows a somewhat larger system, in which the NVDLA
connects to a microcontroller, which is responsible for managing the small
details of programming the NVDLA (and, as such, freeing the main CPU from
servicing low-level NVDLA interrupts).  The latter system also integrates a
SRAM, attached to NVDLA.  (Other units on the system may also have
connections to this SRAM, and share it for their own needs; this is not
shown in the diagram.)</p>
<div class="section" id="configuration-space-bus">
<h3>Configuration space bus<a class="headerlink" href="#configuration-space-bus" title="Permalink to this headline">¶</a></h3>
<p>The CPU uses the CSB (Configuration Space Bus) interface to access NVDLA
registers.  The CSB interface is intentionally extremely simple, and
low-performance; as such, it should be simple to build an adapter between
the CSB and any other system bus that may be supported on a platform.  The
CSB bus consists of three channels: the request channel, the read data
channel, and the write response channel.  These channels are as described
below.</p>
<div class="section" id="clock-and-reset">
<h4>Clock and reset<a class="headerlink" href="#clock-and-reset" title="Permalink to this headline">¶</a></h4>
<p>The CSB interface uses a single clock domain, shared between NVDLA and the
requester.</p>
</div>
<div class="section" id="request-channel">
<h4>Request channel<a class="headerlink" href="#request-channel" title="Permalink to this headline">¶</a></h4>
<p>The request channel follows a valid/ready protocol; a data transaction
occurs on the request channel when and only when the <code class="docutils literal"><span class="pre">valid</span></code> signal (from
the host) and the <code class="docutils literal"><span class="pre">ready</span></code> signal (from NVDLA) are both asserted in the
same clock cycle.  Each request to CSB has a fixed request size of 32 bits
of data, and has a fixed 16bit address size.  CSB does not support any form
of burst requests; each packet sent down the request channel is independent
from any other packet.</p>
<span id="tab-csb-request-channel"></span><table border="1" class="colwidths-given docutils" id="id9">
<caption><span class="caption-number">Table 1 </span><span class="caption-text">Request channel signal description</span><a class="headerlink" href="#id9" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="25%" />
<col width="13%" />
<col width="13%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Data field</th>
<th class="head"># Bits</th>
<th class="head">Direction</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">csb2nvdla_valid</span></code></td>
<td>1</td>
<td>Input</td>
<td>Indicates that a request is valid</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">csb2nvdla_ready</span></code></td>
<td>1</td>
<td>Output</td>
<td>Indicates that the receiver is ready to take a request</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">csb2nvdla_addr</span></code></td>
<td>16</td>
<td>Input</td>
<td>Address. Aligned to word boundary.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">csb2nvdla_wdat</span></code></td>
<td>32</td>
<td>Input</td>
<td>Write data</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">csb2nvdla_write</span></code></td>
<td>1</td>
<td>Input</td>
<td><p class="first">Write flag.</p>
<p><code class="docutils literal"><span class="pre">1'b0</span></code>: Request is a read request.</p>
<p class="last"><code class="docutils literal"><span class="pre">1'b1</span></code>: Request is a write request.</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">csb2nvdla_nposted</span></code></td>
<td>1</td>
<td>Input</td>
<td><p class="first">Non-posted write transaction indicator.</p>
<p><code class="docutils literal"><span class="pre">1'b0</span></code>: Request is a posted write request.</p>
<p><code class="docutils literal"><span class="pre">1'b1</span></code>: Indicates a non-posted write request.</p>
<p>Posted write transactions are writes where the requester does not
expect to and will not receive a write completion from receiver on
write ack channel. The requester will not know if the write
encounters an error.</p>
<p class="last">Non-posted write transactions are writes where the requester expects
to receive a write completion or write error on write ack channel
from receiver.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="read-data-channel">
<h4>Read data channel<a class="headerlink" href="#read-data-channel" title="Permalink to this headline">¶</a></h4>
<p>The read data response channel is described in the below table.  NVDLA
returns read-response data to the host in strict request order; that is to
say, each request packet (above) for which “write” is set to 0 will have
exactly one response, and that response cannot jump forward or backwards
relative to other reads.</p>
<p>The read data channel follows a valid-only protocol; as such, the host
cannot apply back-pressure to the NVDLA on this interface.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">NVDLA does not support error reporting from the CSB.  Illegal reads (e.g. reads directed at an address hole) will return zeroes.</p>
</div>
<span id="tab-csb-read-data-channel"></span><table border="1" class="colwidths-given docutils" id="id10">
<caption><span class="caption-number">Table 2 </span><span class="caption-text">Read data channel signal description</span><a class="headerlink" href="#id10" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="25%" />
<col width="13%" />
<col width="13%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Data field</th>
<th class="head"># Bits</th>
<th class="head">Direction</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nvdla2csb_valid</span></code></td>
<td>1</td>
<td>Output</td>
<td>Indicates that read data is valid.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">nvdla2csb_data</span></code></td>
<td>32</td>
<td>Output</td>
<td>Data corresponding to a read request, or zero in the event of an
error.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="write-response-channel">
<h4>Write response channel<a class="headerlink" href="#write-response-channel" title="Permalink to this headline">¶</a></h4>
<p>The signals associated with the write response channel are described in the
below table. NVDLA will return write completion to the host in request order
for every non-posted write.</p>
<p>The write completion channel also follows a valid-only protocol, and as
such, the host cannot back-pressure NVDLA on this interface.</p>
<span id="tab-csb-write-response-channel"></span><table border="1" class="colwidths-given docutils" id="id11">
<caption><span class="caption-number">Table 3 </span><span class="caption-text">Write completion channel signal description</span><a class="headerlink" href="#id11" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="25%" />
<col width="13%" />
<col width="13%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Data field</th>
<th class="head"># Bits</th>
<th class="head">Direction</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nvdla2csb_wr_complete</span></code></td>
<td>1</td>
<td>Output</td>
<td>Indicates that a CSB write has completed.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="interface-timing">
<h4>Interface timing<a class="headerlink" href="#interface-timing" title="Permalink to this headline">¶</a></h4>
<p>The timing diagram in <a class="reference internal" href="#fig-timing-diagram"><span class="std std-numref">Fig. 10</span></a> illustrates 4
transactions (2 writes, 2 reads) on the CSB bus between a requester and
NVDLA.</p>
<div class="figure align-center" id="id12">
<span id="fig-timing-diagram"></span><a class="reference internal image-reference" href="_images/nvdla-hwarch-csb-timing.svg"><img alt="_images/nvdla-hwarch-csb-timing.svg" src="_images/nvdla-hwarch-csb-timing.svg" /></a>
<p class="caption"><span class="caption-number">Fig. 10 </span><span class="caption-text">Interface timing example on the CSB.</span></p>
</div>
</div>
</div>
<div class="section" id="host-interrupt">
<h3>Host interrupt<a class="headerlink" href="#host-interrupt" title="Permalink to this headline">¶</a></h3>
<p>Along with the configuration space bus, NVDLA provides an asynchronous
(interrupt-driven) return channel to deliver event notifications to the CPU.
The interrupt signal is a level-driven interrupt that is asserted high as
long as the NVDLA core has interrupts pending.  Interrupts are pending if
any bits are set in GLB’s <code class="docutils literal"><span class="pre">INTR_STATUS</span></code> register that are also not masked
out (i.e., set to zero) in the <code class="docutils literal"><span class="pre">INTR_MASK</span></code> register.  The NVDLA interrupt
signal is on the same clock domain as the CSB interface.</p>
<span id="tab-host-interrupt-channel"></span><table border="1" class="colwidths-given docutils" id="id13">
<caption><span class="caption-number">Table 4 </span><span class="caption-text">Host interrupt interface</span><a class="headerlink" href="#id13" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="25%" />
<col width="13%" />
<col width="13%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Data field</th>
<th class="head"># Bits</th>
<th class="head">Direction</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nvdla2core_interrupt</span></code></td>
<td>1</td>
<td>Output</td>
<td>Active high while an interrupt is pending from NVDLA.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="system-interconnect-dbbif">
<h3>System interconnect: DBBIF<a class="headerlink" href="#system-interconnect-dbbif" title="Permalink to this headline">¶</a></h3>
<p>NVDLA has two major interfaces to interact with the memory system, these are
called the DBBIF (which is referred to as <code class="docutils literal"><span class="pre">core2dbb</span></code> in signal naming) and
the SRAMIF (which is referred to as <code class="docutils literal"><span class="pre">core2sram</span></code> in signal naming).  The
DBBIF interface is intended to be connected to an on-chip network which
connects to the system memory, while SRAMIF is intended to be connected with
an optional on-chip SRAM with lower memory latency and potentially higher
throughput.  Both the DBBIF and SRAMIF interfaces are AXI4 compliant.  This
section describes the DBBIF interface in detail.</p>
<p>The NVDLA data backbone interface supports a configurable data bus width of
32, 64, 128, 256 or 512-bits. To tolerate memory latency, internal buffers
can be configured to support a configurable number of outstanding requests
up to 256.</p>
<p>The data backbone interface follows a AXI-like protocol, but makes
assumptions to simplify the interface protocol.</p>
<ul class="simple">
<li>Always issues incremental burst request</li>
<li>Burst size always align with data width</li>
<li>Request address always aligned to data width</li>
<li>Writes must always be acknowledged, reads must always get return data</li>
<li>Writes must be committed to memory when NVDLA gets a write acknowledge</li>
<li>Reads must always get the actual value from memory</li>
</ul>
<div class="section" id="id4">
<h4>Clock and reset<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>The NVDLA DBBIF assumes synchronized data backbone interface with single
clock domain and reset.  Therefore, all NVDLA DBBIF ports are part of the
main NVDLA core clock domain.  Synchronization to the SOC data backbone will
need to be done outside the NVDLA core.</p>
</div>
<div class="section" id="aw-write-request-channel">
<h4>AW (Write request) channel<a class="headerlink" href="#aw-write-request-channel" title="Permalink to this headline">¶</a></h4>
<p>The table below lists all signals on AW channel, with an implied prefix of
<code class="docutils literal"><span class="pre">nvdla_core2dbb_aw_</span></code>.</p>
<span id="tab-dbbif-aw-channel"></span><table border="1" class="colwidths-given docutils" id="id14">
<caption><span class="caption-number">Table 5 </span><span class="caption-text">Data backbone interface signal description – AW channel</span><a class="headerlink" href="#id14" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="25%" />
<col width="13%" />
<col width="13%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Data field</th>
<th class="head"># Bits</th>
<th class="head">Direction</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">awvalid</span></code></td>
<td>1</td>
<td>Output</td>
<td>Write request ready</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">awready</span></code></td>
<td>1</td>
<td>Input</td>
<td>Write request ready</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">awlen</span></code></td>
<td>4</td>
<td>Output</td>
<td>Burst length</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">awaddr</span></code></td>
<td>Config</td>
<td>Output</td>
<td>Write address, can be configured to be 32 or 64bit</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">awid</span></code></td>
<td>8</td>
<td>Output</td>
<td>Write request ID tag</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="ar-read-request-channel">
<h4>AR (Read request) channel<a class="headerlink" href="#ar-read-request-channel" title="Permalink to this headline">¶</a></h4>
<p>The table below lists all signals on the AR channel, with an implied prefix
of <code class="docutils literal"><span class="pre">nvdla_core2dbb_ar_</span></code>.</p>
<span id="tab-dbbif-ar-channel"></span><table border="1" class="colwidths-given docutils" id="id15">
<caption><span class="caption-number">Table 6 </span><span class="caption-text">Data backbone interface signal description – AR channel</span><a class="headerlink" href="#id15" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="25%" />
<col width="13%" />
<col width="13%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Data field</th>
<th class="head"># Bits</th>
<th class="head">Direction</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">arvalid</span></code></td>
<td>1</td>
<td>Output</td>
<td>Read request valid</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">arready</span></code></td>
<td>1</td>
<td>Input</td>
<td>Read request ready</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">arlen</span></code></td>
<td>4</td>
<td>Output</td>
<td>Burst length</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">araddr</span></code></td>
<td>Config</td>
<td>Output</td>
<td>Read address, can be configured to be 32 or 64bit</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">arid</span></code></td>
<td>8</td>
<td>Output</td>
<td>Read request ID tag</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="w-write-data-channel">
<h4>W (Write data) channel<a class="headerlink" href="#w-write-data-channel" title="Permalink to this headline">¶</a></h4>
<p>The table below lists all signals on the W channel, with an implied prefix
of <code class="docutils literal"><span class="pre">nvdla_core2dbb_w_</span></code>.</p>
<span id="tab-dbbif-w-channel"></span><table border="1" class="colwidths-given docutils" id="id16">
<caption><span class="caption-number">Table 7 </span><span class="caption-text">Data backbone interface signal description – W channel</span><a class="headerlink" href="#id16" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="25%" />
<col width="13%" />
<col width="13%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Data field</th>
<th class="head"># Bits</th>
<th class="head">Direction</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">wvalid</span></code></td>
<td>1</td>
<td>Output</td>
<td>Write data valid</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">wready</span></code></td>
<td>1</td>
<td>Input</td>
<td>Write data ready</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">wdata</span></code></td>
<td>Config</td>
<td>Output</td>
<td>Write data. Width configurable to 32/64/128/256/512bit</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">wlast</span></code></td>
<td>1</td>
<td>Output</td>
<td>Last write indicator</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">wstrb</span></code></td>
<td>Config</td>
<td>Output</td>
<td><p class="first">Write-strobes to specify the byte lanes of the data bus that contain
valid information.  Each bit in wstrb represents 8bit on data bus;
<code class="docutils literal"><span class="pre">wstrb[n]</span></code> corresponds to <code class="docutils literal"><span class="pre">wdata[(8*n)+7</span> <span class="pre">:</span> <span class="pre">(8*n)]</span></code>.</p>
<p class="last">The width of <code class="docutils literal"><span class="pre">wstrb</span></code> can be configured to be 4/8/16/32/64
corresponding to data width.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="b-write-response-channel">
<h4>B (Write response) channel<a class="headerlink" href="#b-write-response-channel" title="Permalink to this headline">¶</a></h4>
<p>The table below lists all signals on the B channel, with an implied prefix
of <code class="docutils literal"><span class="pre">nvdla_core2dbb_b_</span></code>.</p>
<span id="tab-dbbif-b-channel"></span><table border="1" class="colwidths-given docutils" id="id17">
<caption><span class="caption-number">Table 8 </span><span class="caption-text">Data backbone interface signal description – B channel</span><a class="headerlink" href="#id17" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="25%" />
<col width="13%" />
<col width="13%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Data field</th>
<th class="head"># Bits</th>
<th class="head">Direction</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">bvalid</span></code></td>
<td>1</td>
<td>Input</td>
<td>Write response valid</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">bready</span></code></td>
<td>1</td>
<td>Output</td>
<td>Write response ready</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">bid</span></code></td>
<td>8</td>
<td>Input</td>
<td>Write response ID</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="r-read-data-channel">
<h4>R (Read data) channel<a class="headerlink" href="#r-read-data-channel" title="Permalink to this headline">¶</a></h4>
<p>The table below lists all signals on the R channel, with an implied prefix
of <code class="docutils literal"><span class="pre">nvdla_core2dbb_r_</span></code>.</p>
<span id="tab-dbbif-r-channel"></span><table border="1" class="colwidths-given docutils" id="id18">
<caption><span class="caption-number">Table 9 </span><span class="caption-text">Data backbone interface signal description – R channel</span><a class="headerlink" href="#id18" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="25%" />
<col width="13%" />
<col width="13%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Data field</th>
<th class="head"># Bits</th>
<th class="head">Direction</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">rvalid</span></code></td>
<td>1</td>
<td>Input</td>
<td>Write response valid</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">rready</span></code></td>
<td>1</td>
<td>Output</td>
<td>Write response ready</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">rlast</span></code></td>
<td>1</td>
<td>Input</td>
<td>Last read data indicator.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">rdata</span></code></td>
<td>Config</td>
<td>Input</td>
<td>Read data with configurable width of 32/64/128/256/512b</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">rid</span></code></td>
<td>8</td>
<td>Input</td>
<td>Read response ID</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="on-chip-sram-interface-sramif">
<h3>On-Chip SRAM Interface - SRAMIF<a class="headerlink" href="#on-chip-sram-interface-sramif" title="Permalink to this headline">¶</a></h3>
<p>The optional NVDLA SRAM interface is used when there is an on-chip SRAM for
the benefit of lower latency and higher throughput.  The SRAM interface
protocol is exactly the same as DBBIF interface, but signals have been
renamed to the prefixes <code class="docutils literal"><span class="pre">nvdla_core2sram_{aw,ar,w,b,r}_</span></code>, for the aw, ar,
w, b and r channels respectively.</p>
</div>
</div>
<div class="section" id="register-interface">
<h2>Register Interface<a class="headerlink" href="#register-interface" title="Permalink to this headline">¶</a></h2>
<p>This section describes the register address space and register definitions.
For each sub-unit, there are status registers, configuration registers,
command registers and profiling registers.</p>
<div class="section" id="ping-pong-synchronization-mechanism">
<h3>Ping-pong Synchronization Mechanism<a class="headerlink" href="#ping-pong-synchronization-mechanism" title="Permalink to this headline">¶</a></h3>
<p>One traditional procedure to program hardware is as follows: first, the CPU
configures registers on an engine, then it sets the engine’s “enable” bit,
then it waits for the hardware to produce a “done” interrupt, and finally it
starts the process over again with a new set of registers.  This style of
programming model will result in the hardware becoming idle between two
consecutive hardware layers, which reduces system efficiency.</p>
<p>In order to hide the CPU’s reprogramming latency, NVDLA introduces the
concept of ping-pong register programming for per-hardware-layer registers.
For most NVDLA subunits, there are two groups of registers; when the subunit
is executing using the configuration from the first register set, the CPU
can program the second group in the background, setting the second group’s
“enable” bit when it is done.  When the hardware has finished processing the
layer described by the first register set, it will clear the “enable” bit of
the first register set, and then switch to the second group if the second
group’s “enable” bit has already been set.  (If the second group’s “enable”
bit has not yet been set, then the hardware becomes idle until programming
is complete.) The process, then, repeats, with the second group becoming the
active group, and the first group becoming the “shadow” group to which the
CPU writes in the background.  This mechanism allows the hardware to switch
smoothly between active layers, wasting no cycles for CPU configuration.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unlike a “shadow register” programming model, values written to the inactive
group in the “ping-pong” programming model do not get copied to a primary
group on activation.  As such, the CPU should make sure that <em>all</em> registers
in a group have been programmed before enabling the hardware layer to run.</p>
</div>
<p>The NVDLA core is built as a series of pipeline stages; each stage is used
to handle hardware layers in whole or in part.  These pipeline stages are:</p>
<ul class="simple">
<li>CDMA (convolution DMA)</li>
<li>CBUF (convolution buffer)</li>
<li>CSC (convolution sequence controller)</li>
<li>CMAC (convolution MAC array)</li>
<li>CACC (convolution accumulator)</li>
<li>SDP (single data processor)</li>
<li>SDP_RDMA (single data processor, read DMA)</li>
<li>PDP (planar data processor)</li>
<li>PDP_RDMA (planar data processor, read DMA)</li>
<li>CDP (channel data processor)</li>
<li>CDP_RDMA (channel data processor, read DMA)</li>
<li>BDMA (bridge DMA)</li>
<li>RUBIK (reshape engine)</li>
</ul>
<p>The first five pipeline stages are part of the <em>convolution core</em> pipeline;
all of these pipeline stages (except for CBUF and CMAC) use linked ping-pong
buffers in order to work together to form HW layers.</p>
<div class="section" id="implementation">
<h4>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h4>
<div class="figure align-center" id="id19">
<span id="fig-regfile"></span><img alt="_images/nvdla-hwarch-regfile.svg" src="_images/nvdla-hwarch-regfile.svg" /><p class="caption"><span class="caption-number">Fig. 11 </span><span class="caption-text">Implementation overview of ping-pong register file.</span></p>
</div>
<p>Each pipeline stage has the ping-pong mechanism built into its register
file, as shown in <a class="reference internal" href="#fig-regfile"><span class="std std-numref">Fig. 11</span></a>.  In detail, each register file
implementation has three register groups; the two ping-pong groups
(duplicated register group 0, and group 1) share the same addresses, and the
third register group is a dedicated non-shadowed group (shown above as the
“single register group”).  The <code class="docutils literal"><span class="pre">PRODUCER</span></code> register field in the
<code class="docutils literal"><span class="pre">POINTER</span></code> register is used to select which of the ping-pong groups is
to be accessed from the CSB interface; the <code class="docutils literal"><span class="pre">CONSUMER</span></code> register field
indicates which register the datapath is sourcing from.  By default, both
pointers select group 0.  Registers are named according to which register
set they belong to; a register is in a duplicated register group if its name
starts with <code class="docutils literal"><span class="pre">D_</span></code>, and otherwise, it is in the single register group.</p>
<p>The registers in the ping-pong groups are parameters to configure hardware
layers.  Each group has an enable register field, which is set by software
and cleared by hardware.  The CPU configured all other fields in the group
before the enable bit; when the enable bit is set, the hardware layer is
ready to execute.  At this point, any writes to register groups that have
the enable bit set will be dropped silently until the hardware layer
completes execution; then, the enable bit is cleared by hardware.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the enable field is set, the hardware layer may either be running or
pending.  Even if the hardware layer is not actively running (i.e., it is
waiting to run), the CPU cannot clear the enable field; any write access to
a register group for which the enable field is set will be silently dropped.</p>
</div>
<p>Most registers in the single-register groups are read-only status registers.
The <code class="docutils literal"><span class="pre">CONSUMER</span></code> and <code class="docutils literal"><span class="pre">PRODUCER</span></code> pointers, described above, reside in the
single group; the <code class="docutils literal"><span class="pre">CONSUMER</span></code> pointer is a read-only register field that
the CPU can check to determine which ping-pong group the datapath has
selected, and the <code class="docutils literal"><span class="pre">PRODUCER</span></code> pointer is fully controleld by the CPU, and
should be set to the correct group before programming a hardware layer.</p>
</div>
<div class="section" id="programming-sequence">
<h4>Programming sequence<a class="headerlink" href="#programming-sequence" title="Permalink to this headline">¶</a></h4>
<p>The following is an example sequence for how to program an NVDLA subunit.
Each NVDLA subunit has the same ping-pong register design; in this sequence,
we choose the CDMA submodule as the example unit that we will program.</p>
<ol class="arabic simple">
<li>After reset, both group 0 and group 1 are in an idle state.  The CPU
should read the <code class="docutils literal"><span class="pre">CDMA_POINTER</span></code> register, and set <code class="docutils literal"><span class="pre">PRODUCER</span></code> to the
value of <code class="docutils literal"><span class="pre">CONSUMER</span></code>.  (After reset, <code class="docutils literal"><span class="pre">CONSUMER</span></code> is expected to be 0.)</li>
<li>The CPU programs the parameters for the first hardware layer into register
group 0.  After configuration completes, the CPU sets the <code class="docutils literal"><span class="pre">enable</span></code> bit in
the <code class="docutils literal"><span class="pre">D_OP_ENABLE</span></code> register.</li>
<li>Hardware begins processing the first hardware layer.</li>
<li>The CPU reads the <code class="docutils literal"><span class="pre">S_STATUS</span></code> register to ensure that register group 1
is idle.</li>
<li>The CPU sets <code class="docutils literal"><span class="pre">PRODUCER</span></code> to 1 and begins programming the parameters for
the second hardware layer into group 1.  After those registers are
programmed, it sets the enable bit in group 1’s <code class="docutils literal"><span class="pre">D_OP_ENABLE</span></code>.</li>
<li>The CPU checks the status of the register group 0 by reading
<code class="docutils literal"><span class="pre">S_STATUS</span></code>; if it is still executing, the CPU waits for an interrupt.</li>
<li>Hardware finishes the processing of the current hardware layer.  Upon
doing so, it sets the status of the previously active group to idle in
the <code class="docutils literal"><span class="pre">S_STATUS</span></code> register, and clears the <code class="docutils literal"><span class="pre">enable</span></code> bit of the
<code class="docutils literal"><span class="pre">D_OP_ENABLE</span></code> register.</li>
<li>Hardware advances the <code class="docutils literal"><span class="pre">CONSUMER</span></code> field to the next register group (in
this case, group 1).  After advancing the <code class="docutils literal"><span class="pre">CONSUMER</span></code> field, it
determines whether the <code class="docutils literal"><span class="pre">enable</span></code> bit is set on the new group.  If so, it
begins processing the next hardware layer immediately; if not, hardware
waits until the <code class="docutils literal"><span class="pre">enable</span></code> bit is set.</li>
<li>Hardware asserts the “done” interrupt for the previous hardware layer.  If
the CPU was blocked waiting for a “done” interrupt, it now proceeds
programming, as above.</li>
<li>Repeat, as needed.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The NVDLA hardware does not have intrinsic support for dependency tracking;
that is to say, hardware layers that are running or pending do not have any
mechanism of blocking each other, if one depends on the output of the other.
As such, the CPU is responsible for ensuring that if a layer depends on the
output of a previous layer, the consuming layer is not scheduled until the
producing layer has finished executing.</p>
</div>
</div>
</div>
<div class="section" id="address-space-layout">
<h3>Address space layout<a class="headerlink" href="#address-space-layout" title="Permalink to this headline">¶</a></h3>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This address space layout is not final, and should be expected to change
in revisions of the NVDLA design leading up to version 1.0.</p>
</div>
<p>The NVDLA requires 256 KiB of MMIO address space for its registers.
Although the base address will vary from system to system, all registers on
the CSB interface start at a base address of <code class="docutils literal"><span class="pre">0x0000_0000</span></code>.  Each subunit
inside of NVDLA is assigned 4 KiB of address space.  (The CBUF subunit does
not have any registers.)  The address mapping inside of NVDLA’s address
space is as shown in table <a class="reference internal" href="#tab-address-space"><span class="std std-numref">Table 10</span></a>.</p>
<p>Some hardware configurations may not have certain subunits enabled; for
instance, smaller implementations of NVDLA may disable SDP, PDP, or CDP.  In
such a case, the address space of those subunits is reserved, and their
registers are not accessible.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Capability registers will be added to determine the configuration of
each NVDLA implementation.</p>
</div>
<table border="1" class="docutils" id="tab-address-space">
<caption><span class="caption-number">Table 10 </span><span class="caption-text">NVDLA address space.</span><a class="headerlink" href="#tab-address-space" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">DLA sub-unit</th>
<th class="head">Start Address</th>
<th class="head">End Address</th>
<th class="head">Size (KiB)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GLB</td>
<td><code class="docutils literal"><span class="pre">0x0000_0000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000_0FFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-odd"><td>Reserved</td>
<td><code class="docutils literal"><span class="pre">0x0000_1000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000_1FFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-even"><td>MCIF</td>
<td><code class="docutils literal"><span class="pre">0x0000_2000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000_2FFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-odd"><td>SRAMIF</td>
<td><code class="docutils literal"><span class="pre">0x0000_3000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000_3FFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-even"><td>BDMA</td>
<td><code class="docutils literal"><span class="pre">0x0000_4000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000_4FFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-odd"><td>CDMA</td>
<td><code class="docutils literal"><span class="pre">0x0000_5000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000_5FFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-even"><td>CSC</td>
<td><code class="docutils literal"><span class="pre">0x0000_6000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000_6FFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-odd"><td>CMAC_A</td>
<td><code class="docutils literal"><span class="pre">0x0000_7000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000_7FFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-even"><td>CMAC_B</td>
<td><code class="docutils literal"><span class="pre">0x0000_8000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000_8FFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-odd"><td>CACC</td>
<td><code class="docutils literal"><span class="pre">0x0000_9000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000_9FFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-even"><td>SDP (RDMA)</td>
<td><code class="docutils literal"><span class="pre">0x0000_A000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000_AFFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-odd"><td>SDP</td>
<td><code class="docutils literal"><span class="pre">0x0000_B000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000_BFFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-even"><td>PDP (RDMA)</td>
<td><code class="docutils literal"><span class="pre">0x0000_C000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000_CFFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-odd"><td>PDP</td>
<td><code class="docutils literal"><span class="pre">0x0000_D000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000_DFFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-even"><td>CDP (RDMA)</td>
<td><code class="docutils literal"><span class="pre">0x0000_E000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000_EFFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-odd"><td>CDP</td>
<td><code class="docutils literal"><span class="pre">0x0000_F000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000_FFFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-even"><td>RUBIK</td>
<td><code class="docutils literal"><span class="pre">0x0001_0000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0001_0FFF</span></code></td>
<td>4</td>
</tr>
<tr class="row-odd"><td>Reserved</td>
<td><code class="docutils literal"><span class="pre">0x0001_1000</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0003_FFFF</span></code></td>
<td>188</td>
</tr>
</tbody>
</table>
<div class="section" id="glb">
<h4>GLB<a class="headerlink" href="#glb" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils" id="tab-glb-registers">
<caption><span class="caption-number">Table 11 </span><span class="caption-text">GLB registers.</span><a class="headerlink" href="#tab-glb-registers" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="20%" />
<col width="16%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Address</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">HW_VERSION</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0000</span></code></td>
<td>HW version of NVDLA</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">INTR_MASK</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0004</span></code></td>
<td>Interrupt mask control</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">INTR_SET</span></code></td>
<td><code class="docutils literal"><span class="pre">0x0008</span></code></td>
<td>Interrupt set control</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">INTR_STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0x000c</span></code></td>
<td>Interrupt status</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="mcif">
<h4>MCIF<a class="headerlink" href="#mcif" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils" id="tab-mcif-registers">
<caption><span class="caption-number">Table 12 </span><span class="caption-text">MCIF registers.</span><a class="headerlink" href="#tab-mcif-registers" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="25%" />
<col width="16%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Address</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CFG_RD_WEIGHT_0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x2000</span></code></td>
<td>Register0 to control the read weight of clients in MCIF</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">CFG_RD_WEIGHT_1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x2004</span></code></td>
<td>Register1 to control the read weight of clients in MCIF</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CFG_RD_WEIGHT_2</span></code></td>
<td><code class="docutils literal"><span class="pre">0x2008</span></code></td>
<td>Register2 to control the read weight of clients in MCIF</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">CFG_WR_WEIGHT_0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x200c</span></code></td>
<td>Register0 to control the write weight of clients in MCIF</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CFG_WR_WEIGHT_1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x2010</span></code></td>
<td>Register1 to control the write weight of clients in MCIF</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">CFG_OUTSTANDING_CNT</span></code></td>
<td><code class="docutils literal"><span class="pre">0x2014</span></code></td>
<td>Outstanding AXI transactions in unit of 64Byte</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0x2018</span></code></td>
<td>Idle status of MCIF</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="sramif">
<h4>SRAMIF<a class="headerlink" href="#sramif" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils" id="tab-cvif-registers">
<caption><span class="caption-number">Table 13 </span><span class="caption-text">SRAMIF registers.</span><a class="headerlink" href="#tab-cvif-registers" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="25%" />
<col width="16%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Address</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CFG_RD_WEIGHT_0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x3000</span></code></td>
<td>Register0 to control the read weight of clients in MCIF</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">CFG_RD_WEIGHT_1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x3004</span></code></td>
<td>Register1 to control the read weight of clients in MCIF</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CFG_RD_WEIGHT_2</span></code></td>
<td><code class="docutils literal"><span class="pre">0x3008</span></code></td>
<td>Register2 to control the read weight of clients in MCIF</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">CFG_WR_WEIGHT_0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x300c</span></code></td>
<td>Register0 to control the write weight of clients in MCIF</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CFG_WR_WEIGHT_1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x3010</span></code></td>
<td>Register1 to control the write weight of clients in MCIF</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">CFG_OUTSTANDING_CNT</span></code></td>
<td><code class="docutils literal"><span class="pre">0x3014</span></code></td>
<td>Outstanding AXI transactions in unit of 64Byte</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0x3018</span></code></td>
<td>Idle status of SRAMIF</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="bdma">
<h4>BDMA<a class="headerlink" href="#bdma" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils" id="tab-bdma-registers">
<caption><span class="caption-number">Table 14 </span><span class="caption-text">BDMA registers.</span><a class="headerlink" href="#tab-bdma-registers" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="29%" />
<col width="15%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Address</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CFG_SRC_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0x4000</span></code></td>
<td>Lower 32bits of source address</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">CFG_SRC_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0x4004</span></code></td>
<td>Higher 32bits of source address when axi araddr is 64bits</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CFG_DST_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0x4008</span></code></td>
<td>Lower 32bits of dest address</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">CFG_DST_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0x400c</span></code></td>
<td>Higher 32bits of dest address when axi awaddr is 64bits</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CFG_LINE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x4010</span></code></td>
<td>Size of one line</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">CFG_CMD</span></code></td>
<td><code class="docutils literal"><span class="pre">0x4014</span></code></td>
<td>Ram type of source and destination</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CFG_LINE_REPEAT</span></code></td>
<td><code class="docutils literal"><span class="pre">0x4018</span></code></td>
<td>Number of lines to be moved in one surface</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">CFG_SRC_LINE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x401c</span></code></td>
<td>Source line stride</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CFG_DST_LINE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x4020</span></code></td>
<td>Destination line stride</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">CFG_SURF_REPEAT</span></code></td>
<td><code class="docutils literal"><span class="pre">0x4024</span></code></td>
<td>Number of surfaces to be moved in one operation</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CFG_SRC_SURF</span></code></td>
<td><code class="docutils literal"><span class="pre">0x4028</span></code></td>
<td>Source surface stride</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">CFG_DST_SURF</span></code></td>
<td><code class="docutils literal"><span class="pre">0x402c</span></code></td>
<td>Destination surface stride</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CFG_OP</span></code></td>
<td><code class="docutils literal"><span class="pre">0x4030</span></code></td>
<td>This register is not used in NVDLA 1.0</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">CFG_LAUNCH0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x4034</span></code></td>
<td>Set it to 1 to kick off operations in group0</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">CFG_LAUNCH1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x4038</span></code></td>
<td>Set it to 1 to kick off operations in group1</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">CFG_STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0x403c</span></code></td>
<td>Enable/Disable of counting stalls</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0x4040</span></code></td>
<td>Status register: idle status of bdma, group0 and group1</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">STAUS_GRP0_READ_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0x4044</span></code></td>
<td>Counting register of group0 read stall</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">STATUS_GRP0_WRITE_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0x4048</span></code></td>
<td>Counting register of group0 write stall</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">STAUS_GRP1_READ_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0x404c</span></code></td>
<td>Counting register of group1 read stall</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">STATUS_GRP1_WRITE_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0x4050</span></code></td>
<td>Counting register of group1 write stall</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cdma">
<h4>CDMA<a class="headerlink" href="#cdma" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils" id="tab-cdma-registers">
<caption><span class="caption-number">Table 15 </span><span class="caption-text">CDMA registers.</span><a class="headerlink" href="#tab-cdma-registers" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="19%" />
<col width="10%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Address</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5000</span></code></td>
<td>Idle status of two register groups</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_POINTER</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5004</span></code></td>
<td>Pointer for CSB master and data path to access groups</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_ARBITER</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5008</span></code></td>
<td><p class="first">WMB and Weight share same port to access external memory.</p>
<p class="last">This register controls the weight factor in the arbiter.</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_CBUF_FLUSH_STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0x500c</span></code></td>
<td>Indicates whether CBUF flush is finished after reset.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_OP_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5010</span></code></td>
<td>Set it to 1 to kick off operation for current register group</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_MISC_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5014</span></code></td>
<td>Configuration of operation: convolution mode, precision, weight reuse, data reuse.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATAIN_FORMAT</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5018</span></code></td>
<td>Input data format and pixel format</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATAIN_SIZE_0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x501c</span></code></td>
<td>Input cube’s width and height</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATAIN_SIZE_1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5020</span></code></td>
<td>Input cube’s channel</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATAIN_SIZE_EXT_0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5024</span></code></td>
<td>Input cube’s width and height after extension</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PIXEL_OFFSET</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5028</span></code></td>
<td>For image-in mode, horizontal offset and vertical offset of the 1 <sup>st</sup> pixel.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DAIN_RAM_TYPE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x502c</span></code></td>
<td>Ram type of input RAM</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DAIN_ADDR_HIGH_0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5030</span></code></td>
<td>Higher 32bits of input data address when axi araddr is 64bits</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DAIN_ADDR_LOW_0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5034</span></code></td>
<td>Lower 32bits of input data address</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DAIN_ADDR_HIGH_1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5038</span></code></td>
<td>Higher 32bits of input data address of UV plane when axi araddr is 64bits</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DAIN_ADDR_LOW_1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x503c</span></code></td>
<td>Lower 32bits of input data address of UV plane</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_LINE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5040</span></code></td>
<td>Line stride of input cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_LINE_UV_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5044</span></code></td>
<td>Line stride of input cube’s UV plane</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_SURF_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5048</span></code></td>
<td>Surface stride of input cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DAIN_MAP</span></code></td>
<td><code class="docutils literal"><span class="pre">0x504c</span></code></td>
<td>Whether input cube is line packed or surface packed</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">RESERVED</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5050</span></code></td>
<td>This address is reserved</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">RESERVED</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5054</span></code></td>
<td>This address is reserved</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_BATCH_NUMBER</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5058</span></code></td>
<td>Number of batches</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_BATCH_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x505c</span></code></td>
<td>The stride of input data cubes when batches &gt; 1</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_ENTRY_PER_SLICE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5060</span></code></td>
<td>Number of CBUF entries used for one input slice</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_FETCH_GRAIN</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5064</span></code></td>
<td>Number of slices to be fetched before sending update information to CSC</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_WEIGHT_FORMAT</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5068</span></code></td>
<td>Whether weight is compressed or not</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_WEIGHT_SIZE_0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x506c</span></code></td>
<td>The size of one kernel in bytes</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_WEIGHT_SIZE_1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5070</span></code></td>
<td>Number of kernels</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_WEIGHT_RAM_TYPE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5074</span></code></td>
<td>Ram type of weight</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_WEIGHT_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5078</span></code></td>
<td>Higher 32bits of weight address when axi araddr is 64bits</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_WEIGHT_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0x507c</span></code></td>
<td>Lower 32bits of weight address</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_WEIGHT_BYTES</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5080</span></code></td>
<td>Total bytes of Weight</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_WGS_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5084</span></code></td>
<td>Higher 32bits of wgs address when axi araddr is 64bits</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_WGS_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5088</span></code></td>
<td>Lower 32bits of wgs address</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_WMB_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0x508c</span></code></td>
<td>Higher 32bits of wmb address when axi araddr is 64bits</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_WMB_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5090</span></code></td>
<td>Lower 32bits of wmb address</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_WMB_BYTES</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5094</span></code></td>
<td>Total bytes of WMB</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_MEAN_FORMAT</span></code></td>
<td><code class="docutils literal"><span class="pre">0x5098</span></code></td>
<td>Whether mean registers are used or not</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_MEAN_GLOBAL_0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x509c</span></code></td>
<td><p class="first">Global mean value for red in RGB or Y in YUV</p>
<p class="last">Global mean value for green in RGB or U in YUV</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_MEAN_GLOBAL_1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50a0</span></code></td>
<td><p class="first">Global mean value for blue in RGB or V in YUV</p>
<p class="last">Global mean value for alpha in ARGB/AYUV or X in XRGB</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_CVT_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50a4</span></code></td>
<td>Enable/disable input data converter in CDMA and number of bits to be truncated in the input data converter</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_CVT_OFFSET</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50a8</span></code></td>
<td>Offset of input data convertor</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_CVT_SCALE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50ac</span></code></td>
<td>Scale of input data convertor</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_CONV_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50b0</span></code></td>
<td>Convolution x stride and convolution y stride</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_ZERO_PADDING</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50b4</span></code></td>
<td>Left/right/top/bottom padding size</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_ZERO_PADDING_VALUE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50b8</span></code></td>
<td>Padding value</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_BANK</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50bc</span></code></td>
<td>Number of data banks and weight banks in CBUF</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_NAN_FLUSH_TO_ZERO</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50c0</span></code></td>
<td>Enable/Disable flushing input NaN to zero</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_NAN_INPUT_DATA_NUM</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50c4</span></code></td>
<td>Count NaN number in input data cube, update per layer</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_NAN_INPUT_WEIGHT_NUM</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50c8</span></code></td>
<td>Count NaN number in weight kernels, update per layer</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_INF_INPUT_DATA_NUM</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50cc</span></code></td>
<td>Count infinity number in input data cube, update per layer</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_INF_INPUT_WEIGHT_NUM</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50d0</span></code></td>
<td>Count infinity number in weight kernels, update per layer</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50d4</span></code></td>
<td>Enable/disable performance counter</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_DAT_READ_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50d8</span></code></td>
<td>Count blocking cycles of read request of input data, update per layer</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_WT_READ_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50dc</span></code></td>
<td>Count blocking cycles of read request of weight data, update per layer</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_DAT_READ_LATENCY</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50e0</span></code></td>
<td>Count total latency cycles of read response of input data, update per layer</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_WT_READ_LATENCY</span></code></td>
<td><code class="docutils literal"><span class="pre">0x50e4</span></code></td>
<td>Count total latency cycles of read request of weight data, update per layer</td>
</tr>
</tbody>
</table>
<p>Note that some registers in the CDMA unit are only used in certain modes; if
these modes are not shown as available in the hardware capability registers,
their registers are not available either.  These registers are as noted below:</p>
<table border="1" class="colwidths-auto docutils" id="tab-cdma-feature-registers">
<caption><span class="caption-number">Table 16 </span><span class="caption-text">CDMA registers that are feature-specific.</span><a class="headerlink" href="#tab-cdma-feature-registers" title="Permalink to this table">¶</a></caption>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Feature</th>
<th class="head">Registers</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Image-in mode</td>
<td><code class="docutils literal"><span class="pre">D_PIXEL_OFFSET</span></code>, <code class="docutils literal"><span class="pre">D_DAIN_ADDR_HIGH_1</span></code>, <code class="docutils literal"><span class="pre">D_DAIN_ADDR_LOW_1</span></code>, <code class="docutils literal"><span class="pre">D_MEAN_FORMAT</span></code>, <code class="docutils literal"><span class="pre">D_MEAN_GLOBAL_0</span></code>, <code class="docutils literal"><span class="pre">D_MEAN_GLOBAL_1</span></code></td>
</tr>
<tr class="row-odd"><td>FP16 data format</td>
<td><code class="docutils literal"><span class="pre">D_NAN_FLUSH_TO_ZERO</span></code>, <code class="docutils literal"><span class="pre">D_NAN_INPUT_DATA_NUM</span></code>, <code class="docutils literal"><span class="pre">D_NAN_INPUT_WEIGHT_NUM</span></code>, <code class="docutils literal"><span class="pre">D_INF_INPUT_DATA_NUM</span></code>, <code class="docutils literal"><span class="pre">D_INF_INPUT_WEIGHT_NUM</span></code></td>
</tr>
<tr class="row-even"><td>Weight compression</td>
<td><code class="docutils literal"><span class="pre">D_WGS_ADDR_HIGH</span></code>, <code class="docutils literal"><span class="pre">D_WGS_ADDR_LOW</span></code>, <code class="docutils literal"><span class="pre">D_WMB_ADDR_HIGH</span></code>, <code class="docutils literal"><span class="pre">D_WMB_ADDR_LOW</span></code>, <code class="docutils literal"><span class="pre">D_WMB_BYTES</span></code></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="csc">
<h4>CSC<a class="headerlink" href="#csc" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-auto docutils" id="tab-csc-registers">
<caption><span class="caption-number">Table 17 </span><span class="caption-text">CSC registers.</span><a class="headerlink" href="#tab-csc-registers" title="Permalink to this table">¶</a></caption>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Address</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6000</span></code></td>
<td>Idle status of two register groups</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_POINTER</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6004</span></code></td>
<td>Pointer for CSB master and data path to access groups</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_OP_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6008</span></code></td>
<td>Set it to 1 to kick off operation for current register group</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_MISC_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0x600c</span></code></td>
<td>Configuration of operation: convolution mode, precision, weight reuse, data reuse.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATAIN_FORMAT</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6010</span></code></td>
<td>Input data format and pixel format</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATAIN_SIZE_EXT_0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6014</span></code></td>
<td>Input cube’s width and height after extension</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATAIN_SIZE_EXT_1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6018</span></code></td>
<td>Input cube’s channel after extension</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_BATCH_NUMBER</span></code></td>
<td><code class="docutils literal"><span class="pre">0x601c</span></code></td>
<td>Number of batches</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_POST_Y_EXTENSION</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6020</span></code></td>
<td>Post extension parameter for image-in</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_ENTRY_PER_SLICE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6024</span></code></td>
<td>Number of CBUF entries used for one input slice</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_WEIGHT_FORMAT</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6028</span></code></td>
<td>Whether weight is compressed or not</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_WEIGHT_SIZE_EXT_0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x602c</span></code></td>
<td>Weight’s width and height after extension</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_WEIGHT_SIZE_EXT_1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6030</span></code></td>
<td>Weight’s channel after extension and number of weight kernels</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_WEIGHT_BYTES</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6034</span></code></td>
<td>Total bytes of Weight</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_WMB_BYTES</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6038</span></code></td>
<td>Total bytes of WMB</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATAOUT_SIZE_0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x603c</span></code></td>
<td>Output cube’s width and height</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATAOUT_SIZE_1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6040</span></code></td>
<td>Output cube’s channel</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_ATOMICS</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6044</span></code></td>
<td>Equals to output_data_cube_width * output_data_cube_height - 1</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_RELEASE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6048</span></code></td>
<td>Slices of CBUF to be released at the end of current layer</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_CONV_STRIDE_EXT</span></code></td>
<td><code class="docutils literal"><span class="pre">0x604c</span></code></td>
<td>Convolution x stride and convolution y stride after extension</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DILATION_EXT</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6050</span></code></td>
<td>Dilation parameter</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_ZERO_PADDING</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6054</span></code></td>
<td>Left/right/top/bottom padding size</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_ZERO_PADDING_VALUE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6058</span></code></td>
<td>Padding value</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_BANK</span></code></td>
<td><code class="docutils literal"><span class="pre">0x605c</span></code></td>
<td>Number of data banks and weight banks in CBUF</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PRA_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0x6060</span></code></td>
<td>PRA truncate in Winograd mode, range: 0~2</td>
</tr>
</tbody>
</table>
<p>Note that some registers in the CSC unit are only used in certain modes; if
these modes are not shown as available in the hardware capability registers,
their registers are not available either.  These registers are as noted below:</p>
<table border="1" class="colwidths-auto docutils" id="tab-csc-feature-registers">
<caption><span class="caption-number">Table 18 </span><span class="caption-text">CSC registers that are feature-specific.</span><a class="headerlink" href="#tab-csc-feature-registers" title="Permalink to this table">¶</a></caption>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Feature</th>
<th class="head">Registers</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Image-in mode</td>
<td><code class="docutils literal"><span class="pre">D_POST_Y_EXTENSION</span></code></td>
</tr>
<tr class="row-odd"><td>Weight compression</td>
<td><code class="docutils literal"><span class="pre">D_WMB_BYTES</span></code></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cmac-a">
<h4>CMAC_A<a class="headerlink" href="#cmac-a" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-auto docutils" id="tab-cmac-a-registers">
<caption><span class="caption-number">Table 19 </span><span class="caption-text">CMAC_A registers.</span><a class="headerlink" href="#tab-cmac-a-registers" title="Permalink to this table">¶</a></caption>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Address</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0x7000</span></code></td>
<td>Idle status of two register groups</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_POINTER</span></code></td>
<td><code class="docutils literal"><span class="pre">0x7004</span></code></td>
<td>Pointer for CSB master and data path to access groups</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_OP_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x7008</span></code></td>
<td>Set it to 1 to kick off operation for current register group</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_MISC_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0x700c</span></code></td>
<td>Configuration of operation: convolution mode, precision, etc.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cmac-b">
<h4>CMAC_B<a class="headerlink" href="#cmac-b" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-auto docutils" id="tab-cmac-b-registers">
<caption><span class="caption-number">Table 20 </span><span class="caption-text">CMAC_B registers.</span><a class="headerlink" href="#tab-cmac-b-registers" title="Permalink to this table">¶</a></caption>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Address</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0x8000</span></code></td>
<td>Idle status of two register groups</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_POINTER</span></code></td>
<td><code class="docutils literal"><span class="pre">0x8004</span></code></td>
<td>Pointer for CSB master and data path to access groups</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_OP_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x8008</span></code></td>
<td>Set it to 1 to kick off operation for current register group</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_MISC_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0x800c</span></code></td>
<td>Configuration of operation: convolution mode, precision, etc.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cacc">
<h4>CACC<a class="headerlink" href="#cacc" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-auto docutils" id="tab-cacc-registers">
<caption><span class="caption-number">Table 21 </span><span class="caption-text">CACC registers.</span><a class="headerlink" href="#tab-cacc-registers" title="Permalink to this table">¶</a></caption>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Address</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0x9000</span></code></td>
<td>Idle status of two register groups</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_POINTER</span></code></td>
<td><code class="docutils literal"><span class="pre">0x9004</span></code></td>
<td>Pointer for CSB master and data path to access groups</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_OP_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x9008</span></code></td>
<td>Set it to 1 to kick off operation for current register group</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_MISC_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0x900c</span></code></td>
<td>Configuration of operation: convolution mode, precision, etc.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATAOUT_SIZE_0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x9010</span></code></td>
<td>Input cube’s width and height after extension</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATAOUT_SIZE_1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x9014</span></code></td>
<td>Input cube’s channel after extension</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATAOUT_ADDR</span></code></td>
<td><code class="docutils literal"><span class="pre">0x9018</span></code></td>
<td>Address of output cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_BATCH_NUMBER</span></code></td>
<td><code class="docutils literal"><span class="pre">0x901c</span></code></td>
<td>Number of batches</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_LINE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x9020</span></code></td>
<td>Line stride of output cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_SURF_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x9024</span></code></td>
<td>Line stride of surface cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATAOUT_MAP</span></code></td>
<td><code class="docutils literal"><span class="pre">0x9028</span></code></td>
<td>Whether output cube is line packed or surface packed</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_CLIP_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0x902c</span></code></td>
<td>Number of bits to be truncated before sending to SDP</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_OUT_SATURATION</span></code></td>
<td><code class="docutils literal"><span class="pre">0x9030</span></code></td>
<td>Output saturation count</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="sdp-rdma">
<h4>SDP_RDMA<a class="headerlink" href="#sdp-rdma" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-auto docutils" id="tab-sdp-rdma-registers">
<caption><span class="caption-number">Table 22 </span><span class="caption-text">SDP_RDMA registers.</span><a class="headerlink" href="#tab-sdp-rdma-registers" title="Permalink to this table">¶</a></caption>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Address</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa000</span></code></td>
<td>Idle status of two register groups</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_POINTER</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa004</span></code></td>
<td>Pointer for CSB master and data path to access groups</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_OP_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa008</span></code></td>
<td>Set it to 1 to kick off operation for current register group</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_WIDTH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa00c</span></code></td>
<td>Input cube’s width</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_HEIGHT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa010</span></code></td>
<td>Input cube’s height</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_CHANNEL</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa014</span></code></td>
<td>Input cube’s channel</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_SRC_BASE_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa018</span></code></td>
<td>Lower 32bits of input data address</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_SRC_BASE_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa01c</span></code></td>
<td>Higher 32bits of input data address when axi araddr is 64bits</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_SRC_LINE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa020</span></code></td>
<td>Line stride of input cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_SRC_SURFACE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa024</span></code></td>
<td>Surface stride of input cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_BRDMA_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa028</span></code></td>
<td>Configuration of BRDMA: enable/disable, data size, Ram type, etc.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_BS_BASE_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa02c</span></code></td>
<td>Lower 32bits address of the bias data cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_BS_BASE_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa030</span></code></td>
<td>Higher 32bits address of the bias data cube when axi araddr is 64bits</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_BS_LINE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa034</span></code></td>
<td>Line stride of bias data cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_BS_SURFACE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa038</span></code></td>
<td>Surface stride of bias data cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_BS_BATCH_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa03c</span></code></td>
<td>Stride of bias data cube in batch mode</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_NRDMA_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa040</span></code></td>
<td>Configuration of NRDMA: enable/disable, data size, Ram type, etc.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_BN_BASE_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa044</span></code></td>
<td>Lower 32bits address of the bias data cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_BN_BASE_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa048</span></code></td>
<td>Higher 32bits address of the bias data cube when axi araddr is 64bits</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_BN_LINE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa04c</span></code></td>
<td>Line stride of bias data cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_BN_SURFACE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa050</span></code></td>
<td>Surface stride of bias data cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_BN_BATCH_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa054</span></code></td>
<td>Stride of bias data cube in batch mode</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_ERDMA_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa058</span></code></td>
<td>Configuration of ERDMA: enable/disable, data size, Ram type, etc.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_EW_BASE_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa05c</span></code></td>
<td>Lower 32bits address of the bias data cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_EW_BASE_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa060</span></code></td>
<td>Higher 32bits address of the bias data cube when axi araddr is 64bits</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_EW_LINE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa064</span></code></td>
<td>Line stride of bias data cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_EW_SURFACE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa068</span></code></td>
<td>Surface stride of bias data cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_EW_BATCH_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa06c</span></code></td>
<td>Stride of bias data cube in batch mode</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_FEATURE_MODE_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa070</span></code></td>
<td>Operation configuration: flying mode, output destination, Direct or Winograd mode, flush NaN to zero, batch number.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_SRC_DMA_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa074</span></code></td>
<td>RAM type of input data cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_STATUS_NAN_INPUT_NUM</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa078</span></code></td>
<td>Input NaN element number</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_STATUS_INF_INPUT_NUM</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa07c</span></code></td>
<td>Input Infinity element number</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa080</span></code></td>
<td>Enable/Disable performance counting</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_MRDMA_READ_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa084</span></code></td>
<td>Count stall cycles of M read DMA for one layer</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_BRDMA_READ_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa088</span></code></td>
<td>Count stall cycles of B read DMA for one layer</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_NRDMA_READ_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa08c</span></code></td>
<td>Count stall cycles of N read DMA for one layer</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_ERDMA_READ_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0xa090</span></code></td>
<td>Count stall cycles of E read DMA for one layer</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="sdp">
<h4>SDP<a class="headerlink" href="#sdp" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-auto docutils" id="tab-sdp-registers">
<caption><span class="caption-number">Table 23 </span><span class="caption-text">SDP registers.</span><a class="headerlink" href="#tab-sdp-registers" title="Permalink to this table">¶</a></caption>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Address</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb000</span></code></td>
<td>Idle status of two register groups</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_POINTER</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb004</span></code></td>
<td>Pointer for CSB master and data path to access groups</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_LUT_ACCESS_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb008</span></code></td>
<td>LUT access address and type</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_LUT_ACCESS_DATA</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb00c</span></code></td>
<td>Data register of read or write LUT</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_LUT_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb010</span></code></td>
<td>LUT’s type: exponent or linear. And the selection between LE and LO tables.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_LUT_INFO</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb014</span></code></td>
<td>LE and LO LUT index offset and selection</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_LUT_LE_START</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb018</span></code></td>
<td>Start of LE LUT’s range</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_LUT_LE_END</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb01c</span></code></td>
<td>End of LE LUT’s range</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_LUT_LO_START</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb020</span></code></td>
<td>Start of LO LUT’s range</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_LUT_LO_END</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb024</span></code></td>
<td>End of LO LUT’s range</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_LUT_LE_SLOPE_SCALE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb028</span></code></td>
<td>Slope scale parameter for LE LUT underflow and overflow, signed value</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_LUT_LE_SLOPE_SHIFT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb02c</span></code></td>
<td>Slope shift parameter for LE_LUT underflow and overflow, signed value</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_LUT_LO_SLOPE_SCALE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb030</span></code></td>
<td>Slope scale parameter for LO LUT underflow and overflow, signed value</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_LUT_LO_SLOPE_SHIFT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb034</span></code></td>
<td>Slope shift parameter for LO_LUT underflow and overflow, signed value</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_OP_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb038</span></code></td>
<td>Set it to 1 to kick off operation for current register group</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_WIDTH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb03c</span></code></td>
<td>Input cube’s width</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_HEIGHT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb040</span></code></td>
<td>Input cube’s height</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_CHANNEL</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb044</span></code></td>
<td>Input cube’s channel</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DST_BASE_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb048</span></code></td>
<td>Lower 32bits of output data address</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DST_BASE_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb04c</span></code></td>
<td>Higher 32bits of output data address when axi awaddr is 64bits</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DST_LINE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb050</span></code></td>
<td>Line stride of output data cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DST_SURFACE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb054</span></code></td>
<td>Surface stride of output data cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DP_BS_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb058</span></code></td>
<td>Configurations of BS module: bypass, algorithm, etc.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DP_BS_ALU_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb05c</span></code></td>
<td>Source type and shifter value of BS ALU</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DP_BS_ALU_SRC_VALUE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb060</span></code></td>
<td>Operand value of BS ALU</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DP_BS_MUL_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb064</span></code></td>
<td>Source type and shifter value of BS MUL</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DP_BS_MUL_SRC_VALUE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb068</span></code></td>
<td>Operand value of BS MUL</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DP_BN_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb06c</span></code></td>
<td>Configurations of BN module: bypass, algorithm, etc.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DP_BN_ALU_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb070</span></code></td>
<td>Source type and shifter value of BN ALU</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DP_BN_ALU_SRC_VALUE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb074</span></code></td>
<td>Operand value of BN ALU</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DP_BN_MUL_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb078</span></code></td>
<td>Source type and shifter value of BN MUL</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DP_BN_MUL_SRC_VALUE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb07c</span></code></td>
<td>Operand value of BN MUL</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DP_EW_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb080</span></code></td>
<td>Configurations of EW module: bypass, algorithm, etc.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DP_EW_ALU_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb084</span></code></td>
<td>Source type and bypass control of EW ALU</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DP_EW_ALU_SRC_VALUE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb088</span></code></td>
<td>Operand value of EW ALU</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DP_EW_ALU_CVT_OFFSET_VALUE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb08c</span></code></td>
<td>Converter offset of EW ALU</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DP_EW_ALU_CVT_SCALE_VALUE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb090</span></code></td>
<td>Converter scale of EW ALU</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DP_EW_ALU_CVT_TRUNCATE_VALUE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb094</span></code></td>
<td>Converter truncate of EW ALU</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DP_EW_MUL_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb098</span></code></td>
<td>Source type and bypass control of EW MUL</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DP_EW_MUL_SRC_VALUE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb09c</span></code></td>
<td>Operand value of EW MUL</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DP_EW_MUL_CVT_OFFSET_VALUE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0a0</span></code></td>
<td>Converter offset of EW MUL</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DP_EW_MUL_CVT_SCALE_VALUE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0a4</span></code></td>
<td>Converter scale of EW MUL</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DP_EW_MUL_CVT_TRUNCATE_VALUE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0a8</span></code></td>
<td>Converter truncate of EW MUL</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DP_EW_TRUNCATE_VALUE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0ac</span></code></td>
<td>Truncate of EW</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_FEATURE_MODE_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0b0</span></code></td>
<td>Operation configuration: flying mode, output destination, Direct or Winograd mode, flush NaN to zero, batch number.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DST_DMA_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0b4</span></code></td>
<td>Destination RAM type</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DST_BATCH_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0b8</span></code></td>
<td>Stride of output cubes in batch mode</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATA_FORMAT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0bc</span></code></td>
<td>Data precision</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_CVT_OFFSET</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0c0</span></code></td>
<td>Output converter offset</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_CVT_SCALE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0c4</span></code></td>
<td>Output converter scale</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_CVT_SHIFT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0c8</span></code></td>
<td>Output converter shifter value</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0cc</span></code></td>
<td>Output of equal mode</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_STATUS_NAN_INPUT_NUM</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0d0</span></code></td>
<td>Input NaN element number</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_STATUS_INF_INPUT_NUM</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0d4</span></code></td>
<td>Input Infinity element number</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_STATUS_NAN_OUTPUT_NUM</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0d8</span></code></td>
<td>Output NaN element number</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0dc</span></code></td>
<td>Enable/Disable performance counting</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_WDMA_WRITE_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0e0</span></code></td>
<td>Count stall cycles of write DMA for one layer</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_LUT_UFLOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0e4</span></code></td>
<td>Element number of both table underflow</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_LUT_OFLOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0e8</span></code></td>
<td>Element number of both table overflow</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_OUT_SATURATION</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0ec</span></code></td>
<td>Element number of both table saturation</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_LUT_HYBRID</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0f0</span></code></td>
<td>Element number of both hit, or both miss situation that element underflow one table and at the same time overflow the other.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_LUT_LE_HIT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0f4</span></code></td>
<td>Element number of only LE table hit</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_LUT_LO_HIT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xb0f8</span></code></td>
<td>Element number of only LO table hit</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="pdp-rdma">
<h4>PDP_RDMA<a class="headerlink" href="#pdp-rdma" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-auto docutils" id="tab-pdp-rdma-registers">
<caption><span class="caption-number">Table 24 </span><span class="caption-text">PDP_RDMA registers.</span><a class="headerlink" href="#tab-pdp-rdma-registers" title="Permalink to this table">¶</a></caption>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Address</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc000</span></code></td>
<td>Idle status of two register groups</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_POINTER</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc004</span></code></td>
<td>Pointer for CSB master and data path to access groups</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_OP_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc008</span></code></td>
<td>Set it to 1 to kick off operation for current register group</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_IN_WIDTH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc00c</span></code></td>
<td>Input data cube’s width</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_IN_HEIGHT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc010</span></code></td>
<td>Input data cube’s height</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_IN_CHANNEL</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc014</span></code></td>
<td>Input data cube’s channel</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_FLYING_MODE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc018</span></code></td>
<td>Indicate source is SDP or external memory</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_SRC_BASE_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc01c</span></code></td>
<td>Lower 32bits of input data address</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_SRC_BASE_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc020</span></code></td>
<td>Higher 32bits of input data address when axi araddr is 64bits</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_SRC_LINE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc024</span></code></td>
<td>Line stride of input cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_SRC_SURFACE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc028</span></code></td>
<td>Surface stride of input cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_SRC_RAM_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc02c</span></code></td>
<td>RAM type of input data cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATA_FORMAT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc030</span></code></td>
<td>Input data cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_OPERATION_MODE_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc034</span></code></td>
<td>Split number</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_POOLING_KERNEL_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc038</span></code></td>
<td>Kernel width and kernel stride</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_POOLING_PADDING_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc03c</span></code></td>
<td>Padding width</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PARTIAL_WIDTH_IN</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc040</span></code></td>
<td>Partial width for first, last and middle partitions</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc044</span></code></td>
<td>Enable/Disable performance counting</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_READ_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0xc048</span></code></td>
<td>Element number that for both LUT underflow.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="pdp">
<h4>PDP<a class="headerlink" href="#pdp" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-auto docutils" id="tab-pdp-registers">
<caption><span class="caption-number">Table 25 </span><span class="caption-text">PDP registers.</span><a class="headerlink" href="#tab-pdp-registers" title="Permalink to this table">¶</a></caption>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Address</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd000</span></code></td>
<td>Idle status of two register groups</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_POINTER</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd004</span></code></td>
<td>Pointer for CSB master and data path to access groups</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_OP_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd008</span></code></td>
<td>Set it to 1 to kick off operation for current register group</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_IN_WIDTH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd00c</span></code></td>
<td>Input data cube’s width</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_IN_HEIGHT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd010</span></code></td>
<td>Input data cube’s height</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_IN_CHANNEL</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd014</span></code></td>
<td>Input data cube’s channel</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_OUT_WIDTH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd018</span></code></td>
<td>Output data cube’s width</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_OUT_HEIGHT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd01c</span></code></td>
<td>Output data cube’s height</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_OUT_CHANNEL</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd020</span></code></td>
<td>Output data cube’s channel</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_OPERATION_MODE_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd024</span></code></td>
<td>Split number</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_NAN_FLUSH_TO_ZERO</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd028</span></code></td>
<td>Option to flush input NaN to zero</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PARTIAL_WIDTH_IN</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd02c</span></code></td>
<td>Partial width for first, last and middle partitions of input cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PARTIAL_WIDTH_OUT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd030</span></code></td>
<td>Partial width for first, last and middle partitions of output cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_POOLING_KERNEL_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd034</span></code></td>
<td>Kernel width and kernel stride</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_RECIP_KERNEL_WIDTH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd038</span></code></td>
<td>Reciprocal of pooling kernel width, set to actual value * (2^16) when INT8/INT16 format enabled. and set to actual value for fp16 precision mode with fp17 data format.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_RECIP_KERNEL_HEIGHT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd03c</span></code></td>
<td>Reciprocal of pooling kernel height, set to actual value * (2^16) when INT8/INT16 format enabled. and set to actual value for fp16 precision mode with fp17 data format.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_POOLING_PADDING_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd040</span></code></td>
<td>Left/right/top/bottom padding size</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_POOLING_PADDING_VALUE_1_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd044</span></code></td>
<td>Padding_value*1</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_POOLING_PADDING_VALUE_2_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd048</span></code></td>
<td>Padding_value*2</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_POOLING_PADDING_VALUE_3_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd04c</span></code></td>
<td>Padding_value*3</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_POOLING_PADDING_VALUE_4_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd050</span></code></td>
<td>Padding_value*4</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_POOLING_PADDING_VALUE_5_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd054</span></code></td>
<td>Padding_value*5</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_POOLING_PADDING_VALUE_6_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd058</span></code></td>
<td>Padding_value*6</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_POOLING_PADDING_VALUE_7_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd05c</span></code></td>
<td>Padding_value*7</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_SRC_BASE_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd060</span></code></td>
<td>Lower 32bits of input data address</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_SRC_BASE_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd064</span></code></td>
<td>Higher 32bits of input data address when axi araddr is 64bits</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_SRC_LINE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd068</span></code></td>
<td>Line stride of input cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_SRC_SURFACE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd06c</span></code></td>
<td>Surface stride of input cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DST_BASE_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd070</span></code></td>
<td>Lower 32bits of output data address</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DST_BASE_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd074</span></code></td>
<td>Higher 32bits of output data address when axi awaddr is 64bits</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DST_LINE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd078</span></code></td>
<td>Line stride of output cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DST_SURFACE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd07c</span></code></td>
<td>Surface stride of output cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DST_RAM_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd080</span></code></td>
<td>RAM type of destination cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATA_FORMAT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd084</span></code></td>
<td>Precision of input data</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_INF_INPUT_NUM</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd088</span></code></td>
<td>Input infinity element number</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_NAN_INPUT_NUM</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd08c</span></code></td>
<td>Input NaN element number</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_NAN_OUTPUT_NUM</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd090</span></code></td>
<td>Output NaN element number</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd094</span></code></td>
<td>Enable/disable performance counting</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_WRITE_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0xd098</span></code></td>
<td>Counting stalls of write requests</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cdp-rdma">
<h4>CDP_RDMA<a class="headerlink" href="#cdp-rdma" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-auto docutils" id="tab-cdp-rdma-registers">
<caption><span class="caption-number">Table 26 </span><span class="caption-text">CDP_RDMA registers.</span><a class="headerlink" href="#tab-cdp-rdma-registers" title="Permalink to this table">¶</a></caption>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Address</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0xe000</span></code></td>
<td>Idle status of two register groups</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_POINTER</span></code></td>
<td><code class="docutils literal"><span class="pre">0xe004</span></code></td>
<td>Pointer for CSB master and data path to access groups</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_OP_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xe008</span></code></td>
<td>Set it to 1 to kick off operation for current register group</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_WIDTH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xe00c</span></code></td>
<td>Input data cube’s width</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_HEIGHT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xe010</span></code></td>
<td>Input data cube’s height</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATA_CUBE_CHANNEL</span></code></td>
<td><code class="docutils literal"><span class="pre">0xe014</span></code></td>
<td>Input data cube’s channel</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_SRC_BASE_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xe018</span></code></td>
<td>Lower 32bits of input data address</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_SRC_BASE_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xe01c</span></code></td>
<td>Higher 32bits of input data address when axi araddr is 64bits</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_SRC_LINE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xe020</span></code></td>
<td>Line stride of input cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_SRC_SURFACE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xe024</span></code></td>
<td>Surface stride of input cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_SRC_DMA_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xe028</span></code></td>
<td>RAM type of input data cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_SRC_COMPRESSION_EN</span></code></td>
<td><code class="docutils literal"><span class="pre">0xe02c</span></code></td>
<td>This register is not used in OpenDLA 1.0</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_OPERATION_MODE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xe030</span></code></td>
<td>Split number</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATA_FORMAT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xe034</span></code></td>
<td>Input data cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xe038</span></code></td>
<td>Enable/Disable performance counting</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_READ_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0xe03c</span></code></td>
<td>Counting stalls of read requests</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cdp">
<h4>CDP<a class="headerlink" href="#cdp" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-auto docutils" id="tab-cdp-registers">
<caption><span class="caption-number">Table 27 </span><span class="caption-text">CDP registers.</span><a class="headerlink" href="#tab-cdp-registers" title="Permalink to this table">¶</a></caption>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Address</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf000</span></code></td>
<td>Idle status of two register groups</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_POINTER</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf004</span></code></td>
<td>Pointer for CSB master and data path to access groups</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_LUT_ACCESS_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf008</span></code></td>
<td>LUT access address and type</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_LUT_ACCESS_DATA</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf00c</span></code></td>
<td>Data register of read or write LUT</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_LUT_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf010</span></code></td>
<td>LUT’s type: exponent or linear. And the selection between LE and LO tables.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_LUT_INFO</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf014</span></code></td>
<td>LE and LO LUT index offset and selection</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_LUT_LE_START_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf018</span></code></td>
<td>Lower 32bits of start of LE LUT’s range</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_LUT_LE_START_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf01c</span></code></td>
<td>Higher 6bits of start of LE LUT’s range</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_LUT_LE_END_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf020</span></code></td>
<td>Lower 32bits of end of LE LUT’s range</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_LUT_LE_END_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf024</span></code></td>
<td>Higher 6bits of end of LE LUT’s range</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_LUT_LO_START_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf028</span></code></td>
<td>Lower 32bits of start of LO LUT’s range</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_LUT_LO_START_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf02c</span></code></td>
<td>Higher 6bits of start of LO LUT’s range</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_LUT_LO_END_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf030</span></code></td>
<td>Lower 32bits of end of LO LUT’s range</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_LUT_LO_END_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf034</span></code></td>
<td>Higher 6bits of end of LO LUT’s range</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_LUT_LE_SLOPE_SCALE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf038</span></code></td>
<td>Slope scale parameter for LE LUT underflow and overflow, signed value</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_LUT_LE_SLOPE_SHIFT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf03c</span></code></td>
<td>Slope shift parameter for LE_LUT underflow and overflow, signed value</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_LUT_LO_SLOPE_SCALE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf040</span></code></td>
<td>Slope scale parameter for LO LUT underflow and overflow, signed value</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_LUT_LO_SLOPE_SHIFT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf044</span></code></td>
<td>Slope shift parameter for LO_LUT underflow and overflow, signed value</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_OP_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf048</span></code></td>
<td>Set it to 1 to kick off operation for current register group</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_FUNC_BYPASS</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf04c</span></code></td>
<td>Square sum process bypass control and multiplier after interpolator bypass control</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DST_BASE_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf050</span></code></td>
<td>Lower 32bits of output data address</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DST_BASE_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf054</span></code></td>
<td>Higher 32bits of output data address when axi awaddr is 64bits</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DST_LINE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf058</span></code></td>
<td>Line stride of output cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DST_SURFACE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf05c</span></code></td>
<td>Surface stride of output cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DST_DMA_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf060</span></code></td>
<td>RAM type of output data cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DST_COMPRESSION_EN</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf064</span></code></td>
<td>This register is not used in OpenDLA 1.0</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATA_FORMAT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf068</span></code></td>
<td>Precision of input data</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_NAN_FLUSH_TO_ZERO</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf06c</span></code></td>
<td>Option to flush input NaN to zero</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_LRN_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf070</span></code></td>
<td>Normalization length</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATIN_OFFSET</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf074</span></code></td>
<td>Input data convertor offset</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATIN_SCALE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf078</span></code></td>
<td>Input data convertor scale</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATIN_SHIFTER</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf07c</span></code></td>
<td>Input data convertor shifter value</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATOUT_OFFSET</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf080</span></code></td>
<td>Output data convertor offset</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATOUT_SCALE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf084</span></code></td>
<td>Output data convertor scale</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATOUT_SHIFTER</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf088</span></code></td>
<td>Output data convertor shifter value</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_NAN_INPUT_NUM</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf08c</span></code></td>
<td>input NaN element number</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_INF_INPUT_NUM</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf090</span></code></td>
<td>input Infinity element number</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_NAN_OUTPUT_NUM</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf094</span></code></td>
<td>output NaN element number</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_OUT_SATURATION</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf098</span></code></td>
<td>saturated element number.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf09c</span></code></td>
<td>Enable/Disable performance counting</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_WRITE_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf0a0</span></code></td>
<td>Element number that for both LUT under-flow</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_LUT_UFLOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf0a4</span></code></td>
<td>Element number that for both LUT under-flow</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_LUT_OFLOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf0a8</span></code></td>
<td>Element number that for both LUT over-flow</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_LUT_HYBRID</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf0ac</span></code></td>
<td>Element number that for both LUT miss, one is over-flow and the other is overflow</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_LUT_LE_HIT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf0b0</span></code></td>
<td>Element number that for LE_lut hit only</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_LUT_LO_HIT</span></code></td>
<td><code class="docutils literal"><span class="pre">0xf0b4</span></code></td>
<td>Element number that for LO_lut hit only</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id5">
<h4>RUBIK<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-auto docutils" id="tab-rubik-registers">
<caption><span class="caption-number">Table 28 </span><span class="caption-text">RUBIK registers.</span><a class="headerlink" href="#tab-rubik-registers" title="Permalink to this table">¶</a></caption>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Address</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">S_STATUS</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10000</span></code></td>
<td>Idle status of two register groups</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">S_POINTER</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10004</span></code></td>
<td>Pointer for CSB master and data path to access groups</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_OP_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10008</span></code></td>
<td>Set it to 1 to kick off operation for current register group</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_MISC_CFG</span></code></td>
<td><code class="docutils literal"><span class="pre">0x1000c</span></code></td>
<td>Operation mode and precision</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DAIN_RAM_TYPE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10010</span></code></td>
<td>RAM type of input cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATAIN_SIZE_0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10014</span></code></td>
<td>Input data cube’s width and height</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DATAIN_SIZE_1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10018</span></code></td>
<td>Input data cube’s channel</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DAIN_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0x1001c</span></code></td>
<td>Higher 32bits of input data address when axi araddr is 64bits</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DAIN_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10020</span></code></td>
<td>Lower 32bits of input data address</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DAIN_LINE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10024</span></code></td>
<td>Line stride of input data cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DAIN_SURF_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10028</span></code></td>
<td>Surface stride of input data cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DAIN_PLANAR_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x1002c</span></code></td>
<td>Input data planar stride, for merge mode only</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DAOUT_RAM_TYPE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10030</span></code></td>
<td>RAM type of output cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DATAOUT_SIZE_1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10034</span></code></td>
<td>Output data cube’s channel</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DAOUT_ADDR_HIGH</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10038</span></code></td>
<td>Higher 32bits of output data address when axi awaddr is 64bits</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DAOUT_ADDR_LOW</span></code></td>
<td><code class="docutils literal"><span class="pre">0x1003c</span></code></td>
<td>Lower 32bits of output data address</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DAOUT_LINE_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10040</span></code></td>
<td>Line stride of output data cube</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_CONTRACT_STRIDE_0</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10044</span></code></td>
<td><p class="first">Input stride for each X step.</p>
<p>Equals to (DATAOUT_CHANNEL+1) * BPE / 32 * DAIN_SURF_STRIDE</p>
<p class="last">(BPE = (IN_PRECISION == INT8) ? 1 : 2;)</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_CONTRACT_STRIDE_1</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10048</span></code></td>
<td><p class="first">Output stride corresponding to each line in input cube.</p>
<p class="last">equals to (DECONV_Y_STRIDE+1) * DAOUT_LINE_STRIDE</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DAOUT_SURF_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x1004c</span></code></td>
<td>Surface stride of output data cube</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_DAOUT_PLANAR_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10050</span></code></td>
<td>Output data planar stride, for split mode only</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_DECONV_STRIDE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10054</span></code></td>
<td>Deconvolution x stride and y stride</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_ENABLE</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10058</span></code></td>
<td>Enable/Disable performance counting</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">D_PERF_READ_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0x1005c</span></code></td>
<td>RD_STALL Count stall cycles of read DMA for one layer</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">D_PERF_WRITE_STALL</span></code></td>
<td><code class="docutils literal"><span class="pre">0x10060</span></code></td>
<td>WR_STALL Count stall cycles of write DMA for one layer</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>


        </div>
        <div class="col-xs-12 col-md-3">
          
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Hardware Architectural Specification</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#functional-description">Functional Description</a><ul>
<li><a class="reference internal" href="#convolution-operations">Convolution Operations</a><ul>
<li><a class="reference internal" href="#direct-convolution-mode">Direct Convolution Mode</a></li>
<li><a class="reference internal" href="#image-input-convolution-mode">Image-Input Convolution Mode</a></li>
<li><a class="reference internal" href="#winograd-convolution-mode">Winograd Convolution Mode</a></li>
<li><a class="reference internal" href="#batching-convolution-mode">Batching Convolution Mode</a></li>
<li><a class="reference internal" href="#convolution-buffer">Convolution Buffer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#single-data-point-operations">Single Data Point Operations</a><ul>
<li><a class="reference internal" href="#linear-functions">Linear Functions</a></li>
<li><a class="reference internal" href="#non-linear-functions">Non-Linear Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#planar-data-operations">Planar Data Operations</a></li>
<li><a class="reference internal" href="#multi-plane-operations">Multi-Plane Operations</a></li>
<li><a class="reference internal" href="#data-memory-and-reshape-operations">Data Memory and Reshape Operations</a><ul>
<li><a class="reference internal" href="#bridge-dma">Bridge DMA</a></li>
<li><a class="reference internal" href="#data-reshape-engine">Data Reshape Engine</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#hardware-parameters">Hardware Parameters</a><ul>
<li><a class="reference internal" href="#feature-selection">Feature Selection</a><ul>
<li><a class="reference internal" href="#data-type">Data Type</a></li>
<li><a class="reference internal" href="#id1">Winograd</a></li>
<li><a class="reference internal" href="#id2">Batching</a></li>
<li><a class="reference internal" href="#sparse-compression">Sparse Compression</a></li>
<li><a class="reference internal" href="#second-memory-bus">Second Memory Bus</a></li>
<li><a class="reference internal" href="#image-input">Image Input</a></li>
<li><a class="reference internal" href="#single-data-point-support">Single Data Point Support</a></li>
<li><a class="reference internal" href="#bridge-dma-support">Bridge DMA Support</a></li>
<li><a class="reference internal" href="#data-reshape-engine-support">Data Reshape Engine Support</a></li>
</ul>
</li>
<li><a class="reference internal" href="#design-sizing">Design Sizing</a><ul>
<li><a class="reference internal" href="#atomicc">Atomic–C</a></li>
<li><a class="reference internal" href="#atomick">Atomic–K</a></li>
<li><a class="reference internal" href="#single-data-point-throughput">Single Data Point Throughput</a></li>
<li><a class="reference internal" href="#planar-data-processor-throughput">Planar Data Processor Throughput</a></li>
<li><a class="reference internal" href="#cross-channel-data-processor-throughput">Cross-Channel Data Processor Throughput</a></li>
<li><a class="reference internal" href="#convolution-buffer-banks">Convolution Buffer Banks</a></li>
<li><a class="reference internal" href="#convolution-buffer-bank-size">Convolution Buffer Bank Size</a></li>
<li><a class="reference internal" href="#convolution-batching">Convolution Batching</a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-types-and-precision">Data Types and Precision</a><ul>
<li><a class="reference internal" href="#precision-scaling-convertor">Precision Scaling Convertor</a></li>
<li><a class="reference internal" href="#precision-shifter">Precision Shifter</a></li>
<li><a class="reference internal" href="#look-up-table">Look Up Table</a></li>
</ul>
</li>
<li><a class="reference internal" href="#small-nvdla-implementation-example">Small NVDLA Implementation Example</a></li>
<li><a class="reference internal" href="#large-nvdla-implementation-example">Large NVDLA Implementation Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#external-interfaces">External Interfaces</a><ul>
<li><a class="reference internal" href="#configuration-space-bus">Configuration space bus</a><ul>
<li><a class="reference internal" href="#clock-and-reset">Clock and reset</a></li>
<li><a class="reference internal" href="#request-channel">Request channel</a></li>
<li><a class="reference internal" href="#read-data-channel">Read data channel</a></li>
<li><a class="reference internal" href="#write-response-channel">Write response channel</a></li>
<li><a class="reference internal" href="#interface-timing">Interface timing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#host-interrupt">Host interrupt</a></li>
<li><a class="reference internal" href="#system-interconnect-dbbif">System interconnect: DBBIF</a><ul>
<li><a class="reference internal" href="#id4">Clock and reset</a></li>
<li><a class="reference internal" href="#aw-write-request-channel">AW (Write request) channel</a></li>
<li><a class="reference internal" href="#ar-read-request-channel">AR (Read request) channel</a></li>
<li><a class="reference internal" href="#w-write-data-channel">W (Write data) channel</a></li>
<li><a class="reference internal" href="#b-write-response-channel">B (Write response) channel</a></li>
<li><a class="reference internal" href="#r-read-data-channel">R (Read data) channel</a></li>
</ul>
</li>
<li><a class="reference internal" href="#on-chip-sram-interface-sramif">On-Chip SRAM Interface - SRAMIF</a></li>
</ul>
</li>
<li><a class="reference internal" href="#register-interface">Register Interface</a><ul>
<li><a class="reference internal" href="#ping-pong-synchronization-mechanism">Ping-pong Synchronization Mechanism</a><ul>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
<li><a class="reference internal" href="#programming-sequence">Programming sequence</a></li>
</ul>
</li>
<li><a class="reference internal" href="#address-space-layout">Address space layout</a><ul>
<li><a class="reference internal" href="#glb">GLB</a></li>
<li><a class="reference internal" href="#mcif">MCIF</a></li>
<li><a class="reference internal" href="#sramif">SRAMIF</a></li>
<li><a class="reference internal" href="#bdma">BDMA</a></li>
<li><a class="reference internal" href="#cdma">CDMA</a></li>
<li><a class="reference internal" href="#csc">CSC</a></li>
<li><a class="reference internal" href="#cmac-a">CMAC_A</a></li>
<li><a class="reference internal" href="#cmac-b">CMAC_B</a></li>
<li><a class="reference internal" href="#cacc">CACC</a></li>
<li><a class="reference internal" href="#sdp-rdma">SDP_RDMA</a></li>
<li><a class="reference internal" href="#sdp">SDP</a></li>
<li><a class="reference internal" href="#pdp-rdma">PDP_RDMA</a></li>
<li><a class="reference internal" href="#pdp">PDP</a></li>
<li><a class="reference internal" href="#cdp-rdma">CDP_RDMA</a></li>
<li><a class="reference internal" href="#cdp">CDP</a></li>
<li><a class="reference internal" href="#id5">RUBIK</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="vp.html"
                        title="previous chapter">Virtual Platform</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="hw/format.html"
                        title="next chapter">Data Formats</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/hwarch.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        </div>
      </div>
    </div>
  </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <div class="container">
      <div class="row">
      <h3>Navigation</h3>
      <ul>
        <li class="right first">
          <a href="hw/format.html" title="Data Formats"
             >next</a></li>
        <li class="right">
          <a href="vp.html" title="Virtual Platform"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">NVDLA Open Source Project</a>&#187;</li>
        <li class="nav-item nav-item-1"><a href="contents.html">Documentation</a>&#187;</li> 
      </ul>
      </div>
      </div>
    </div>
<div class="footer" role="contentinfo">
<div class="container">
<div class="row">
&#169; <a
href="copyright.html">Copyright</a> 2017, NVIDIA Corporation.
<a href="http://www.nvidia.com/object/legal_info.html">Legal Information.</a>
<a href="http://www.nvidia.com/object/privacy_policy.html">Privacy Policy.</a>
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.5.
</div>
</div>
</div>
  </body>
</html>